import com.maxeler.maxcompiler.v2.kernelcompiler.KernelLib;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEFix.SignMode;
import com.maxeler.maxcompiler.v2.utils.Bits;
import java.util.List;
import java.util.ArrayList;


class Def {




	///////////////////////// FPGA Configuration /////////////////////////

	// FPGA Frequency
	public static final int KernelFrequencyMAX4 = 150;
	public static final int KernelFrequencyMAX3 = 100;
	
	// Fanout Limit
	public static final int MaxFanout 			= 6;
	public static final double PipeFactor 		= 0.85;
	
	// Latency
	public static final int QUpdateLatency 	= 160; 	// hXcOffset + fromhXcValidtoXcJoinR
	public static final int BookKeepingLatency	= 220; 	// BookKeepingOffset
	public static final int REnlargeLatency 	= 220; 	// REnlargeLatency
	public static final int FetchLatency 		= 80; 	// KElemInvLatency
	public static final int RShrinkLatency 		= 220; 	// RShrinkLatency


	///////////////////////// SVM Parameters /////////////////////////
	
	// Kernel Settings
	public static final int DataDim 			= 1;
	public static final int numBlocks 			= 4;
	public static final int blockDim 			= 4;
	public static final int streamLength 		= 40;

	// Window Size = numBlocks * blockDim
	public static final int WinSize 			= numBlocks * blockDim;
	public static final double ep 			= 0.01;
	public static final double C 				= 1000;
	public static final double sigma_sq 		= 50;
	public static final double eps 			= 1e-6;
	public static final double BookKeepingTH 	= 100000;


	///////////////////////// Types /////////////////////////
	
	// Precision
	public static final int FractionalBits = 40;
	
	// Default Fix-Point Type
	public static final DFEType FixType 			= KernelLib.dfeFixOffset(56, -FractionalBits, SignMode.TWOSCOMPLEMENT);
	public static final DFEType betaType 			= FixType;
	public static final DFEType gammaType 		= FixType;
	public static final DFEType thetaType 			= FixType;
	public static final DFEType hXiType 			= FixType;
	public static final DFEType RType 			= FixType;
	
	// High Range Fix-Point Type
	public static final DFEType HighFixType 		= KernelLib.dfeFixOffset(64, -FractionalBits, SignMode.TWOSCOMPLEMENT);
	public static final DFEType DataYType 		= HighFixType;
	public static final DFEType RCalcType 		= HighFixType;
	public static final DFEType BookKeepingType 	= HighFixType;
	
	// Input Type
	public static final DFEType InputType 			= KernelLib.dfeFloat(11, 53);
	
	// Data X Types
	// DataType should be able to hold X[i], and X[i] - X[j]
	// DataMultType should be able to hold (X[i] - X[j])^2
	public static final DFEType DataType 			= KernelLib.dfeFixOffset(32, -24, SignMode.TWOSCOMPLEMENT);
	public static final DFEType DataMultType 		= KernelLib.dfeFixOffset(36, -24, SignMode.TWOSCOMPLEMENT);

	// Q Type
	public static final DFEType QType = KernelLib.dfeFixOffset(FractionalBits+1, -FractionalBits, SignMode.UNSIGNED);


	///////////////////////// Software Utility Functions /////////////////////////

	// Float Input Data Generator
	public static List<Bits> FloatVectorDataGenerator(double [][] data, int numTicks, int VectorWidth) {
		final List<Bits> encodedData = new ArrayList<Bits>(numTicks);
		for (int i=0; i<numTicks; ++i) {
			Bits thisStepBits = InputType.encodeConstant(data[i][0]);
			for (int j=1; j<VectorWidth; ++j){
				thisStepBits = InputType.encodeConstant(data[i][j]).cat(thisStepBits);
			}
			encodedData.add(thisStepBits);
		}
		return encodedData;
	}

}
