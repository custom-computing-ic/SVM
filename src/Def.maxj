import com.maxeler.maxcompiler.v2.kernelcompiler.KernelLib;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEFix.SignMode;
import com.maxeler.maxcompiler.v2.utils.Bits;
import java.util.List;
import java.util.ArrayList;
import java.lang.Math;


class Def {

	///////////////////////// FPGA Configuration /////////////////////////

	// FPGA Frequency
	public static final int KernelFrequencyMAX4 = 150;
	public static final int KernelFrequencyMAX3 = 100;
	
	// Fanout Limit
	public static final int MaxFanout = 6;
	
	// Kernel Settings
	public static final int DataDim 		= 30;
	public static final int numBlocks 		= 4;
	public static final int blockDim 		= 120;
	public static final int streamLength 	= 8;
	
	// Latency
	public static final int FetchLatency 	= 80;
	public static final int RShrinkLatency 	= 200;


	///////////////////////// SVM Parameters /////////////////////////

	// Window Size = numBlocks * blockDim
	public static final int WinSize 		= numBlocks * blockDim;
	public static final double ep 		= 0.01;
	public static final double C 			= 1000;
	public static final double sigma_sq 	= 50;
	public static final double eps 		= 1e-7;
	

	///////////////////////// Types /////////////////////////
	
	// Default Fix-Point Type used in various places
	public static final DFEType FixType = KernelLib.dfeFixOffset(56, -40, SignMode.TWOSCOMPLEMENT);

	// Data X Types
	// DataType should be able to hold X[i], and X[i] - X[j]
	// DataMultType should be able to hold (X[i] - X[j])^2
	public static final DFEType DataType = KernelLib.dfeFixOffset(32, -24, SignMode.TWOSCOMPLEMENT);
	public static final DFEType DataMultType = KernelLib.dfeFixOffset(36, -24, SignMode.TWOSCOMPLEMENT);

	// Data Y Type: used by dataY and b
	public static final DFEType DataYType = KernelLib.dfeFixOffset(64, -40, SignMode.TWOSCOMPLEMENT);

	// Default CalcType
	public static final DFEType CalcType = KernelLib.dfeFloat(8, 24);
	
	// Q Type
	public static final DFEType QType = KernelLib.dfeFixOffset(40, -39, SignMode.UNSIGNED);
	
	// theta Type
	public static final DFEType thetaType = FixType;
	public static final DFEType thetaKAccumulatorType = KernelLib.dfeFixOffset(64, -40, SignMode.TWOSCOMPLEMENT);
	
	// R Type
	public static final DFEType RType = FixType;
	public static final DFEType RCalcType = KernelLib.dfeFixOffset(72, -40, SignMode.TWOSCOMPLEMENT);
	
	// betaType
	public static final DFEType betaType = FixType;
	
	// gammaType
	public static final DFEType gammaType = FixType;
	
	// hXi Type
	public static final DFEType hXiType = FixType;
	
	// BookKeeping Type
	public static final double BookKeepingTH = 16000;
	public static final DFEType BookKeepingType = KernelLib.dfeFixOffset(64, -40, SignMode.TWOSCOMPLEMENT);


	///////////////////////// Software Utility Functions /////////////////////////

	// Float Input Data Generator
	public static List<Bits> FloatVectorDataGenerator(double [][] data, int numTicks, int VectorWidth) {
		final List<Bits> encodedData = new ArrayList<Bits>(numTicks);
		for (int i=0; i<numTicks; ++i) {
			Bits thisStepBits = DataType.encodeConstant(data[i][0]);
			for (int j=1; j<VectorWidth; ++j){
				thisStepBits = DataType.encodeConstant(data[i][j]).cat(thisStepBits);
			}
			encodedData.add(thisStepBits);
		}
		return encodedData;
	}

	// RBFKernel
	public static double RBFKernel (int [] X1, int [] X2, int DataDim, double sigma_sq) {
		double sum = 0;
		for (int i=0; i<DataDim; ++i) sum -= (X1[i] - X2[i]) * (X1[i] - X2[i]);
		return Math.exp(sum/2/sigma_sq);
	}


}
