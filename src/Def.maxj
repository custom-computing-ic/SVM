import com.maxeler.maxcompiler.v2.kernelcompiler.KernelLib;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEFix.SignMode;
import com.maxeler.maxcompiler.v2.utils.Bits;
import java.util.List;
import java.util.ArrayList;


class Def {


	///////////////////////// SVM Parameters /////////////////////////

	// Settings for OrderBookData
	// Kernel Settings
	public static final int DataDim 			= 16;
	public static final int numBlocks 			= 5;
	public static final int blockDim 			= 80;

	// Window Size = numBlocks * blockDim
	public static final int WinSize 			= numBlocks * blockDim;
	public static final double ep 			= 1500*0.0001;
	public static final double C 				= 5000;
	public static final double sigma_sq 		= 0.0625;
	public static final double BookKeepingTH 	= 100000;


	// Settings for SimpleDataSet
	// Kernel Settings
/*	public static final int DataDim 			= 1;
	public static final int numBlocks 			= 4;
	public static final int blockDim 			= 4;

	// Window Size = numBlocks * blockDim
	public static final int WinSize 			= numBlocks * blockDim;
	public static final double ep 			= 0.01;
	public static final double C 				= 1000;
	public static final double sigma_sq 		= 50;
	public static final double BookKeepingTH 	= 100000;
*/


	///////////////////////// FPGA Configuration /////////////////////////

	// FPGA Frequency
	public static final int KernelFrequencyMAX4 = 150;
	public static final int KernelFrequencyMAX3 = 100;
	
	// Fanout Limit
	public static final int MaxFanout 			= 6;
	public static final double PipeFactor 		= 0.85;
	
	// Latency
	public static final int QUpdateLatency 	= 130; 	// hXcOffset + fromhXcValidtoXcJoinR
	public static final int BookKeepingLatency	= 220; 	// BookKeepingOffset
	public static final int REnlargeLatency 	= 220; 	// REnlargeLatency
	public static final int FetchLatency 		= 80; 	// KElemInvLatency
	public static final int RShrinkLatency 		= 220; 	// RShrinkLatency
	
	// Initial Cycles
	// NOTE: Set them to avoid using undefined data from negative stream offset
	public static final int bInitCycles 			= 200; 	// (bOffset, bOffset+QUpdateLatency+blockDim)
	public static final int hXiInitCycles 		= 200; 	// (hXiOffset, hXiOffset+QUpdateLatency+blockDim)
	public static final int thetaInitCycles 		= 200; 	// (thetaOffset, thetaOffset+QUpdateLatency+blockDim)
	public static final int REnlargeInitCycles 	= 200; 	// >=QUpdateLatency
	public static final int hXcInitCycles 		= 82+blockDim; 	// ~(hXcOffset+blockDim)
	public static final int RInternalCycles 		= 300; 	// (ROffset, QUpdateLatency+BookKeepingLatency)


	///////////////////////// Types /////////////////////////
	
	// Precision - Number of Fractional Bits
	public static final int FractionalBits = 40;
	
	// Basic Fix-Point Type
	public static final DFEType BaseFixType 		= KernelLib.dfeFixOffset(56, -FractionalBits, SignMode.TWOSCOMPLEMENT);
	public static final DFEType DataYType 		= BaseFixType;
	public static final DFEType KernelSumType 	= BaseFixType;
	public static final DFEType hXiType 			= BaseFixType;
	public static final DFEType thetaType 			= BaseFixType;

	// High Range Fix-Point Type
	public static final DFEType HighFixType 		= KernelLib.dfeFixOffset(70, -FractionalBits, SignMode.TWOSCOMPLEMENT);
	public static final DFEType RType 			= HighFixType;
	public static final DFEType RCalcType 		= HighFixType;
	public static final DFEType betaType 			= HighFixType;
	public static final DFEType gammaType 		= HighFixType;
	
	// Very High Range Fix-Point Type
	public static final DFEType VeryHighFixType 	= KernelLib.dfeFixOffset(80, -FractionalBits, SignMode.TWOSCOMPLEMENT);
	public static final DFEType BookKeepingType 	= VeryHighFixType;
	
	// Data X Types
	public static final DFEType InputType 			= KernelLib.dfeFloat(11, 53);
	// DataType should be able to hold X[i], and X[i] - X[j]; DataMultType should be able to hold (X[i] - X[j])^2
	public static final DFEType DataType 			= KernelLib.dfeFixOffset(52, -40, SignMode.TWOSCOMPLEMENT);
	public static final DFEType DataMultType 		= KernelLib.dfeFixOffset(52, -40, SignMode.TWOSCOMPLEMENT);

	// Q Type
	public static final DFEType QType = KernelLib.dfeFixOffset(FractionalBits+1, -FractionalBits, SignMode.UNSIGNED);


	///////////////////////// Software Utility Functions /////////////////////////

	// Float Input Data Generator
	public static List<Bits> FloatVectorDataGenerator(double [][] data, int numTicks, int VectorWidth) {
		final List<Bits> encodedData = new ArrayList<Bits>(numTicks);
		for (int i=0; i<numTicks; ++i) {
			Bits thisStepBits = InputType.encodeConstant(data[i][0]);
			for (int j=1; j<VectorWidth; ++j){
				thisStepBits = InputType.encodeConstant(data[i][j]).cat(thisStepBits);
			}
			encodedData.add(thisStepBits);
		}
		return encodedData;
	}

}
