import com.maxeler.maxcompiler.v2.kernelcompiler.KernelLib;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEFix.SignMode;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.KernelMath;
import com.maxeler.maxcompiler.v2.utils.Bits;
import java.util.List;
import java.util.ArrayList;
import java.lang.Math;

import maxpower.KernelBinaryOp.Add;
import maxpower.TreeReduce;


class Def {

	///////////////////////// Manager Settings /////////////////////////

	// Pipelining factor
	public static final double PipeliningFactor = 0.75;

	// FPGA Frequency
	public static final int KernelFrequency = 100;
	
	
	///////////////////////// Kernel Settings /////////////////////////

	// IMPORTANT: WinSize = numBlocks * blockDim;
	public static final int DataDim 		= 1; // 30
	public static final int numBlocks 		= 4;
	public static final int blockDim 		= 20;
	public static final int streamLength 	= 8;


	///////////////////////// SVM Parameters /////////////////////////

	// Window Size = numBlocks * blockDim
	public static final int WinSize = numBlocks * blockDim;
	
	// RSize - theoretical maximum RSize is (WinSize+1)
	public static final int RSize = WinSize;

	// epsilon
	public static final double ep = 0.01;  //50
	
	// C
	public static final double C = 1000;  //32768
	
	// sigma_sq
	public static final double sigma_sq = 50;  //50
	
	// eps 
	public static final double eps = 1e-6;
	

	///////////////////////// Types /////////////////////////

	// Input Data Type
	public static final DFEType DataType = KernelLib.dfeFloat(8, 24);

	// CalcType
	public static final DFEType CalcType = KernelLib.dfeFloat(8, 24);
	
	// BookKeeping Type
	public static final double BookKeepingTH = 30000;
	public static final DFEType BookKeepingType = KernelLib.dfeFixMax(40, 30000, SignMode.UNSIGNED);

	// Feature Vector of Input Data Type
	public static final DFEVectorType<DFEVar> DataVecType = new DFEVectorType<DFEVar>(DataType, DataDim);

	// Boolean Type
	public static final DFEType BoolType = KernelLib.dfeBool();


	///////////////////////// Utility Functions For Hardware /////////////////////////
	
	// RBF Kernel
	public static DFEVar RBFKernel(DFEVector<DFEVar>X1, DFEVector<DFEVar>X2) {
		
		// Calculate Norm using Input Data Type - to save resource
		DFEVar[] summands = new DFEVar[DataDim];
		for (int i=0; i<DataDim; ++i) {
			summands[i] = (X1[i] - X2[i]) * (X1[i] - X2[i]);
		}
		DFEVar sum = TreeReduce.reduce(new Add<DFEVar>(), summands);
		
		// Cast sum into CalcType
		DFEVar sum_float = sum.cast(CalcType);
		
		return KernelMath.exp(sum_float*(-0.5/sigma_sq));
	}
	


	///////////////////////// Utility Functions For Tests /////////////////////////

	// Input Data Generator - For Tests
	public static List<Bits> FloatVectorDataGenerator(float [][] data, int numTicks, int VectorWidth) {
		final List<Bits> encodedData = new ArrayList<Bits>(numTicks);
		for (int i=0; i<numTicks; ++i) {
			Bits thisStepBits = KernelLib.dfeFloat(8, 24).encodeConstant(data[i][0]);
			for (int j=1; j<VectorWidth; ++j){
				thisStepBits = KernelLib.dfeFloat(8, 24).encodeConstant(data[i][j]).cat(thisStepBits);
			}
			encodedData.add(thisStepBits);
		}
		return encodedData;
	}

	// RBFKernel
	public static double RBFKernel (int [] X1, int [] X2, int DataDim, double sigma_sq) {
		double sum = 0;
		for (int i=0; i<DataDim; ++i) sum -= (X1[i] - X2[i]) * (X1[i] - X2[i]);
		return Math.exp(sum/2/sigma_sq);
	}


}
