import maxpower.FanoutLimiter;

import com.maxeler.maxcompiler.v2.kernelcompiler.KernelLib;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.KernelMath;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.Reductions;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.Counter;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.WrapMode;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Mem.RamWriteMode;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.memory.Memory;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;
import com.maxeler.maxcompiler.v2.utils.MathUtils;

/**
 * This class maintains Matrix Q
 *	- Store Q in small blockDim-by-blockDim blocks for parallel access
 *	- Provide an interface for traversing through a certain row: Q[Row][Col]
 * 		- Row = BaseAddrRow*blockDim+OffsetAddrRow
 * 		During a traverse, BaseAddrRow and OffsetAddrRow should be fixed
 *		- Col: generated by built-in counter or using external input AddrCol
 * 		- QValVec is the vector read interface using built-in counter as Col address
 * 		- QVal is the individual read interface using external input as Col address
 *	- EnWrite should be true only when updating Q
 * 	- When updating, output are new values (write before read)
 *
 *
 * @author Patrick Shao
 *
 * @param <numBlocks> Number of blocks in each 1D Dimension - WinSize = numBlocks * blockDim
 * @param <blockDim> 1D Dimension of the block - Block Size = blockDim^2
 * @param <Q_IN> Incoming Q vector from KernelCalc - width is numBlocks
 * @param <BaseAddrRow> Base Address of Row, range [0, numBlocks-1]
 * @param <OffsetAddrRow> Offset Address of Row, range [0, blockDim-1]
 * @param <EnWrite> Enable Q update
 * @param <EnIterate> Enable built-in counter to generate Column Address
 * @param <BaseAddrCol> Base Address of Column
 * @param <OffsetAddrCol> Offset Address of Column
 *
 */


class QMem extends KernelLib{

	private final DFEVector<DFEVar> QValVec;
	private final DFEVector<DFEVar> QVecForGammaVCalc;
	private final DFEVar QVal;
	private final DFEVar hasQUpdateFinished;

	public DFEVector<DFEVar> getQValVec() 	{return QValVec;}
	public DFEVector<DFEVar> getQVecForGammaVCalc() 	{return QVecForGammaVCalc;}
	public DFEVar getQVal() 	{return QVal;}
	public DFEVar hasFinished()		{return hasQUpdateFinished;}


	QMem ( 	KernelLib owner,
			int numBlocks,
			int blockDim,
			DFEVar SSize,
			DFEVector<DFEVar> Q_IN,		// Kernel Vector of Xc and dataX
			DFEVar BaseAddrRow_IN,		// BaseAddr of Row
			DFEVar OffsetAddrRow_IN,		// OffsetAddr of Row
			DFEVar EnWrite_IN,			// Write Enable - true during Q update
			DFEVar EnIterate,				// Start Iteration (reset built-in counter) - true on the starting cycle of Q update and hCalc
			DFEVar BaseAddrCol, 			// BaseAddr of Col
			DFEVar OffsetAddrCol, 			// OffsetAddr of Col
			DFEVar beginGammaVCalc,		// begin Gamma V Calculating
			DFEVar isGammaVCalculating)	// is Gamma V Calculating
	{

		super(owner);

		/////////////////////// Vector Type ///////////////////////

		DFEVectorType<DFEVar> VecType = new DFEVectorType<DFEVar>(Def.QType, numBlocks);

    		/////////////////////// Fanout ///////////////////////

		FanoutLimiter<DFEVar> BaseAddrRow = new FanoutLimiter<DFEVar>(BaseAddrRow_IN, Def.MaxFanout);
		FanoutLimiter<DFEVar> OffsetAddrRow = new FanoutLimiter<DFEVar>(OffsetAddrRow_IN, Def.MaxFanout);
		FanoutLimiter<DFEVar> EnWrite = new FanoutLimiter<DFEVar>(EnWrite_IN, Def.MaxFanout);
		FanoutLimiter<DFEVar> isGammaVCalculatingFanout = new FanoutLimiter<DFEVar>(isGammaVCalculating, Def.MaxFanout);



		/////////////////////// Address Generator for Xc Update ///////////////////////

		// Type Cast
		DFEVar OffsetAddrRow_CAST = OffsetAddrRow.get().cast(dfeUInt(MathUtils.bitsToAddress(blockDim*blockDim)));
		DFEVar OffsetAddrCol_CAST = OffsetAddrCol.cast(dfeUInt(MathUtils.bitsToAddress(blockDim*blockDim)));

		// VAddr: OffsetAddrRow + [0,1,2,...]*blockDim
                AddrGenerator VAddrGen = new AddrGenerator(owner, blockDim, blockDim*blockDim, EnIterate);
                DFEVar VAddr = VAddrGen.getAddr() + OffsetAddrRow_CAST;
                FanoutLimiter<DFEVar> VAddrFanout = new FanoutLimiter<DFEVar>(VAddr, Def.MaxFanout);

		// HAddr: blockDim*OffsetAddrRow + [0,1,2,...]
                AddrGenerator HAddrGen = new AddrGenerator(owner, 1, blockDim, EnIterate);
                DFEVar HAddr = HAddrGen.getAddr().cast(dfeUInt(MathUtils.bitsToAddress(blockDim*blockDim))) + blockDim*OffsetAddrRow_CAST;
                FanoutLimiter<DFEVar> HAddrFanout = new FanoutLimiter<DFEVar>(HAddr, Def.MaxFanout);

                // hasQUpdateFinished - true on the last cycle of Q Update
                hasQUpdateFinished = (HAddrGen.getAddr() === blockDim-1) & EnWrite.get();


		/////////////////////// Address Generator for Gamma V Calculation ///////////////////////

                // Inner Loop
		DFEVar SSizeForGammaCalc = Reductions.streamHold(SSize, beginGammaVCalc).cast(dfeUInt(16));
		DFEVar Max = SSizeForGammaCalc + 1;
                Count.Params GammaInnerCounterParam = control.count.makeParams(16)
                							.withInitValue(0)
                							.withMax(Max)
                							.withWrapMode(WrapMode.COUNT_LT_MAX_THEN_WRAP)
                							.withReset(beginGammaVCalc);
                Counter GammaInnerCounter = control.count.makeCounter(GammaInnerCounterParam);

		// Outer Loop
                Count.Params GammaOuterCounterParam = control.count.makeParams(MathUtils.bitsToAddress(blockDim*blockDim))
                							.withInitValue(0)
                							.withMax(blockDim)
                							.withEnable(GammaInnerCounter.getWrap())
                							.withWrapMode(WrapMode.COUNT_LT_MAX_THEN_WRAP)
                							.withReset(beginGammaVCalc);
		Counter GammaOuterCounter = control.count.makeCounter(GammaOuterCounterParam);
		DFEVar OffsetAddrRowGammaVCalc = GammaOuterCounter.getCount();

		// Block Address for Gamma V Calculation
		DFEVar VAddrGammaV = OffsetAddrCol_CAST * blockDim + OffsetAddrRowGammaVCalc;
		DFEVar HAddrGammaV = OffsetAddrRowGammaVCalc * blockDim + OffsetAddrCol_CAST;
		FanoutLimiter<DFEVar> VAddrGammaVFanout = new FanoutLimiter<DFEVar>(VAddrGammaV, Def.MaxFanout);
		FanoutLimiter<DFEVar> HAddrGammaVFanout = new FanoutLimiter<DFEVar>(HAddrGammaV, Def.MaxFanout);


    		/////////////////////// External Column Address ///////////////////////

		DFEVar VAddrExt = OffsetAddrCol_CAST * blockDim + OffsetAddrRow.get().cast(dfeUInt(MathUtils.bitsToAddress(blockDim*blockDim)));
		DFEVar HAddrExt = OffsetAddrRow.get().cast(dfeUInt(MathUtils.bitsToAddress(blockDim*blockDim))) * blockDim + OffsetAddrCol_CAST;
		FanoutLimiter<DFEVar> VAddrExtFanout = new FanoutLimiter<DFEVar>(VAddrExt, Def.MaxFanout);
		FanoutLimiter<DFEVar> HAddrExtFanout = new FanoutLimiter<DFEVar>(HAddrExt, Def.MaxFanout);


                /////////////////////// Blocks ///////////////////////

                // Create QBlocks
                DFEVar [][] QVecElemFromBlock = new DFEVar[numBlocks][numBlocks];
                DFEVar [][] QElemFromBlock = new DFEVar[numBlocks][numBlocks];
                for (int X=0; X<numBlocks; ++X) {
                	for (int Y=0; Y<=X; ++Y) {
                		QBlock block = new QBlock (owner, X, Y, blockDim, Q_IN[X], Q_IN[Y], BaseAddrRow.get(), OffsetAddrRow.get(), VAddrFanout.get(), HAddrFanout.get(), VAddrExtFanout.get(), HAddrExtFanout.get(), EnWrite.get(), VAddrGammaVFanout.get(), HAddrGammaVFanout.get(), isGammaVCalculatingFanout.get());
                		QVecElemFromBlock[X][Y] = block.getQVecElem();
                		QElemFromBlock[X][Y] = block.getQElem();
                	}
                }

                // Wiring Outputs for QValVec
                QValVec = VecType.newInstance(this);
                for (int pos=0; pos<numBlocks; ++pos) {
                	DFEVector<DFEVar> toMux = VecType.newInstance(this);
                	// X=pos, Y=0:pos - Vertical Blocks and DBlock
                	for (int Y=0; Y<=pos;++Y) {
                		toMux[Y] <== QVecElemFromBlock[pos][Y];
                	}
                	// Y=pos, X=pos+1:numBlocks-1 - Horizontal Blocks
                	for (int X=pos+1; X<numBlocks; ++X) {
                		toMux[X] <== QVecElemFromBlock[X][pos];
                	}
                	// Multiplexer
                	QValVec[pos] <== control.mux(BaseAddrRow.get(), toMux.getElementsAsList());
                }

                // Wiring Outputs for QVal
		DFEVector<DFEVar> QValTemp = VecType.newInstance(this);
                for (int pos=0; pos<numBlocks; ++pos) {
                	DFEVector<DFEVar> toMux = VecType.newInstance(this);
                	// X=pos, Y=0:pos - Vertical Blocks and DBlock
                	for (int Y=0; Y<=pos;++Y) {
                		toMux[Y] <==QElemFromBlock[pos][Y];
                	}
                	// Y=pos, X=pos+1:numBlocks-1 - Horizontal Blocks
                	for (int X=pos+1; X<numBlocks; ++X) {
                		toMux[X] <== QElemFromBlock[X][pos];
                	}
                	// Multiplexer
                	QValTemp[pos] <== control.mux(BaseAddrCol, toMux.getElementsAsList());
                }
                QVal = control.mux(BaseAddrRow.get(), QValTemp.getElementsAsList());

		// Wiring Outputs for QVecForGammaVCalc
		QVecForGammaVCalc = VecType.newInstance(this);
                for (int pos=0; pos<numBlocks; ++pos) {
                	DFEVector<DFEVar> toMux = VecType.newInstance(this);
                	// X=pos, Y=0:pos-1 - Vertical Blocks
                	for (int Y=0; Y<pos;++Y) {
                		toMux[Y] <== QVecElemFromBlock[pos][Y];
                	}
                	// Y=pos, X=pos:numBlocks-1 - DBlock and Horizontal Blocks
                	for (int X=pos; X<numBlocks; ++X) {
                		toMux[X] <== QElemFromBlock[X][pos];
                	}
                	// Multiplexer
                	QVecForGammaVCalc[pos] <== control.mux(BaseAddrCol, toMux.getElementsAsList());
                }


	}

	private class QBlock extends KernelLib {

		private final DFEVar QVecElem;
		private final DFEVar QElem;

		public DFEVar getQVecElem() 	{return QVecElem;}
		public DFEVar getQElem() 	{return QElem;}

		QBlock ( 	KernelLib owner,
					int X,
					int Y,
					int blockDim,
					DFEVar Q_X,
					DFEVar Q_Y,
					DFEVar BaseAddr,
					DFEVar OffsetAddr,
					DFEVar VAddr,
					DFEVar HAddr,
					DFEVar VAddrExt,
					DFEVar HAddrExt,
					DFEVar EnWrite,
					DFEVar VAddrGammaV,
					DFEVar HAddrGammaV,
					DFEVar isGammaVCalculating)
		{

			super(owner);

			if (X>Y) {
				//VBlock or HBlock or unrelated
				DFEVar isVBlock = (BaseAddr===X);
				DFEVar isHBlock = (BaseAddr===Y);
				DFEVar isRelated = isVBlock | isHBlock;

				// Column Address from internal address generator
				DFEVar Addr = isVBlock ? VAddr : HAddr;
				DFEVar Q_IN = isVBlock ? Q_Y : Q_X;
				DFEVar En = isRelated & EnWrite;

				// Column Address from external input
				DFEVar AddrExt = isVBlock ? VAddrExt : HAddrExt;

				// Memory
				DFEVar PortAddr = isGammaVCalculating ? VAddrGammaV : Addr;
				DFEVar ReadAddr = isGammaVCalculating ? HAddrGammaV : AddrExt;
				Memory<DFEVar> Q = mem.alloc(Def.QType, blockDim*blockDim);
				Q.mapToCPU("QBlockX"+X+"Y"+Y);
				QVecElem = Q.port(PortAddr, Q_IN, En, RamWriteMode.WRITE_FIRST);
				QElem = Q.read(ReadAddr);
			}
			else if (X==Y){
				// DBlock or unrelated
				DFEVar isDBlock = (BaseAddr===X);
				DFEVar isRelated = isDBlock;

				// Column Address from internal address generator
				DFEVar Addr = KernelMath.min(VAddr, HAddr);
				DFEVar Q_IN = Q_X;
				DFEVar En = isRelated & EnWrite;

				// Column Address from external input
				DFEVar AddrExt = KernelMath.min(VAddrExt, HAddrExt);

				// Memory
				DFEVar ReadAddr = isGammaVCalculating ? KernelMath.min(VAddrGammaV, HAddrGammaV) : AddrExt;
				Memory<DFEVar> Q = mem.alloc(Def.QType, blockDim*blockDim);
				Q.mapToCPU("QBlockX"+X+"Y"+Y);
				QVecElem = Q.port(Addr, Q_IN, En, RamWriteMode.WRITE_FIRST);
				QElem = Q.read(ReadAddr);
			}
			else {
				throw new IllegalArgumentException("[ERROR] There must be X>=Y, as we store only upper triangle matrix.");
			}

		}


	}

}
