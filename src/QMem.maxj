import com.maxeler.maxcompiler.v2.kernelcompiler.KernelLib;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.memory.Memory;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Mem.RamWriteMode;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.KernelMath;
import com.maxeler.maxcompiler.v2.utils.MathUtils;


import maxpower.FanoutLimiter;

/**
 * This class maintains Matrix Q 
 *	- Store Q in small blockDim-by-blockDim blocks for parallelised access
 *	- Provide an interface for traversing through a certain row: Q[Row][Col]
 * 		- Row = BaseAddrRow*blockDim+OffsetAddrRow
 * 		During a traverse, BaseAddrRow and OffsetAddrRow should be fixed
 *		- Col: generated by built-in counter or using external input AddrCol
 * 		- QValVec is the vector read interface using built-in counter as Col address
 * 		- QVal is the individual read interface using external input as Col address
 *	- EnWrite should be true only when updating Q
 * 	- When updating, output are new values
 *
 *
 * @author Patrick Shao
 *
 * @param <numBlocks> Number of blocks in each 1D Dimension - WinSize = numBlocks * blockDim
 * @param <blockDim> 1D Dimension of the block - Block Size = blockDim^2
 * @param <Q_IN> Incoming Q vector from KernelCalc - width is numBlocks
 * @param <BaseAddrRow> Base Address of Row, range [0, numBlocks-1]
 * @param <OffsetAddrRow> Offset Address of Row, range [0, blockDim-1]
 * @param <EnWrite> Enable Q update
 * @param <EnIterate> Enable built-in counter to generate Column Address
 * @param <BaseAddrCol> Base Address of Column
 * @param <OffsetAddrCol> Offset Address of Column
 * 
 */


class QMem extends KernelLib{

	private DFEVector<DFEVar> QValVec;
	private DFEVar QVal;
	private DFEVar hasQUpdateFinished;
	
	public DFEVector<DFEVar> getQValVec() 	{return QValVec;}
	public DFEVar getQVal() 	{return QVal;}
	public DFEVar hasFinished()		{return hasQUpdateFinished;}


	QMem ( 	KernelLib owner,
			int numBlocks,
			int blockDim,
			DFEVector<DFEVar> Q_IN,	// Kernel Vector of Xc and dataX
			DFEVar BaseAddrRow_IN,	// BaseAddr of Row
			DFEVar OffsetAddrRow_IN,	// OffsetAddr of Row
			DFEVar EnWrite_IN,		// Write Enable - true during Q update
			DFEVar EnIterate,			// Start Iteration (reset built-in counter) - true on the starting cycle of Q update and hCalc
			DFEVar BaseAddrCol, 		// BaseAddr of Col
			DFEVar OffsetAddrCol) 		// OffsetAddr of Col
	{

		super(owner);
		
		/////////////////////// Vector Type ///////////////////////
		
		DFEVectorType<DFEVar> VecType = new DFEVectorType<DFEVar>(Def.QType, numBlocks);
		
    		/////////////////////// Fanout ///////////////////////		

		FanoutLimiter<DFEVar> BaseAddrRow = new FanoutLimiter<DFEVar>(BaseAddrRow_IN, Def.MaxFanout);
		FanoutLimiter<DFEVar> OffsetAddrRow = new FanoutLimiter<DFEVar>(OffsetAddrRow_IN, Def.MaxFanout);
		FanoutLimiter<DFEVar> EnWrite = new FanoutLimiter<DFEVar>(EnWrite_IN, Def.MaxFanout);
		
		
		/////////////////////// Address Generator for Xc Update and hCalc ///////////////////////
		
		// Type Cast
		DFEVar OffsetAddrRow_CAST = OffsetAddrRow.get().cast(dfeUInt(MathUtils.bitsToAddress(blockDim*blockDim)));
		DFEVar OffsetAddrCol_CAST = OffsetAddrCol.cast(dfeUInt(MathUtils.bitsToAddress(blockDim*blockDim)));
		
		// VAddr: OffsetAddrRow + [0,1,2,...]*blockDim
                AddrGenerator VAddrGen = new AddrGenerator(owner, blockDim, blockDim*blockDim, EnIterate);
                DFEVar VAddr = VAddrGen.getAddr() + OffsetAddrRow_CAST;
                FanoutLimiter<DFEVar> VAddrFanout = new FanoutLimiter<DFEVar>(VAddr, Def.MaxFanout);

		// HAddr: blockDim*OffsetAddrRow + [0,1,2,...]
                AddrGenerator HAddrGen = new AddrGenerator(owner, 1, blockDim, EnIterate);
                DFEVar HAddr = HAddrGen.getAddr().cast(dfeUInt(MathUtils.bitsToAddress(blockDim*blockDim))) + blockDim*OffsetAddrRow_CAST;
                FanoutLimiter<DFEVar> HAddrFanout = new FanoutLimiter<DFEVar>(HAddr, Def.MaxFanout);

                // hasQUpdateFinished - true on the last cycle of Q Update
                hasQUpdateFinished = (HAddrGen.getAddr() === blockDim-1) & EnWrite.get();


    		/////////////////////// External Column Address ///////////////////////
                
		DFEVar VAddrExt = OffsetAddrCol_CAST * blockDim + OffsetAddrRow.get().cast(dfeUInt(MathUtils.bitsToAddress(blockDim*blockDim)));
		DFEVar HAddrExt = OffsetAddrRow.get().cast(dfeUInt(MathUtils.bitsToAddress(blockDim*blockDim))) * blockDim + OffsetAddrCol_CAST;
		FanoutLimiter<DFEVar> VAddrExtFanout = new FanoutLimiter<DFEVar>(VAddrExt, Def.MaxFanout);
		FanoutLimiter<DFEVar> HAddrExtFanout = new FanoutLimiter<DFEVar>(HAddrExt, Def.MaxFanout);

            
                /////////////////////// Blocks ///////////////////////
                
                // Create QBlocks
                DFEVar [][] QVecElemFromBlock = new DFEVar[numBlocks][numBlocks];
                DFEVar [][] QElemFromBlock = new DFEVar[numBlocks][numBlocks];
                for (int X=0; X<numBlocks; ++X) {
                	for (int Y=0; Y<=X; ++Y) {
                		QBlock block = new QBlock (owner, X, Y, blockDim, Q_IN[X], Q_IN[Y], BaseAddrRow.get(), OffsetAddrRow.get(), VAddrFanout.get(), HAddrFanout.get(), VAddrExtFanout.get(), HAddrExtFanout.get(), EnWrite.get());
                		QVecElemFromBlock[X][Y] = block.getQVecElem();
                		QElemFromBlock[X][Y] = block.getQElem();
                	}
                }
                
                // Wiring Outputs for QValVec
                QValVec = VecType.newInstance(this);
                for (int pos=0; pos<numBlocks; ++pos) {
                	DFEVector<DFEVar> toMux = VecType.newInstance(this);
                	// X=pos, Y=0:pos - Vertical Blocks and DBlock
                	for (int Y=0; Y<=pos;++Y) {
                		toMux[Y] <== QVecElemFromBlock[pos][Y];
                	}
                	// Y=pos, X=pos+1:numBlocks-1 - Horizontal Blocks
                	for (int X=pos+1; X<numBlocks; ++X) {
                		toMux[X] <== QVecElemFromBlock[X][pos];
                	}
                	// Multiplexer
                	QValVec[pos] <== control.mux(BaseAddrRow.get(), toMux.getElementsAsList());
                }
                
                // Wiring Outputs for QVal
		DFEVector<DFEVar> QValTemp = VecType.newInstance(this);
                for (int pos=0; pos<numBlocks; ++pos) {
                	DFEVector<DFEVar> toMux = VecType.newInstance(this);
                	// X=pos, Y=0:pos - Vertical Blocks and DBlock
                	for (int Y=0; Y<=pos;++Y) {
                		toMux[Y] <==QElemFromBlock[pos][Y];
                	}
                	// Y=pos, X=pos+1:numBlocks-1 - Horizontal Blocks
                	for (int X=pos+1; X<numBlocks; ++X) {
                		toMux[X] <== QElemFromBlock[X][pos];
                	}
                	// Multiplexer
                	QValTemp[pos] <== control.mux(BaseAddrCol, toMux.getElementsAsList());
                }
                QVal = control.mux(BaseAddrRow.get(), QValTemp.getElementsAsList());
	
	}

	private class QBlock extends KernelLib {
	
		private final DFEVar QVecElem;
		private final DFEVar QElem;
		
		public DFEVar getQVecElem() 	{return QVecElem;}
		public DFEVar getQElem() 	{return QElem;}
	
		QBlock ( 	KernelLib owner,
					int X, 
					int Y, 
					int blockDim, 
					DFEVar Q_X, 
					DFEVar Q_Y, 
					DFEVar BaseAddr,
					DFEVar OffsetAddr, 
					DFEVar VAddr, 
					DFEVar HAddr, 
					DFEVar VAddrExt, 
					DFEVar HAddrExt,
					DFEVar EnWrite) 
		{
			
			super(owner);
		
			if (X>Y) { 
				//VBlock or HBlock or unrelated
				DFEVar isVBlock = (BaseAddr===X);
				DFEVar isHBlock = (BaseAddr===Y);
				DFEVar isRelated = isVBlock | isHBlock;

				// Column Address from internal address generator
				DFEVar Addr = isVBlock ? VAddr : HAddr;
				DFEVar Q_IN = isVBlock ? Q_Y : Q_X;
				DFEVar En = isRelated & EnWrite;

				// Column Address from external input
				DFEVar AddrExt = isVBlock ? VAddrExt : HAddrExt;
			
				// Memory
				Memory<DFEVar> Q = mem.alloc(Def.QType, blockDim*blockDim);
				QVecElem = Q.port(Addr, Q_IN, En, RamWriteMode.WRITE_FIRST);
				QElem = Q.read(AddrExt);
			}
			else if (X==Y){ 
				// DBlock or unrelated		
				DFEVar isDBlock = (BaseAddr===X);
				DFEVar isRelated = isDBlock;

				// Column Address from internal address generator
				DFEVar Addr = KernelMath.min(VAddr, HAddr);
				DFEVar Q_IN = Q_X; 
				DFEVar En = isRelated & EnWrite;
				
				// Column Address from external input
				DFEVar AddrExt = KernelMath.min(VAddrExt, HAddrExt);

				// Memory			
				Memory<DFEVar> Q = mem.alloc(Def.QType, blockDim*blockDim);
				if ((X==0)&&(Y==0))Q.mapToCPU("QBlockX"+X+"Y"+Y);
				QVecElem = Q.port(Addr, Q_IN, En, RamWriteMode.WRITE_FIRST);
				QElem = Q.read(AddrExt);
			}
			else {
				throw new IllegalArgumentException("[ERROR] There must be X>=Y, as we store only upper triangle matrix.");
			}

		}
	
	
	}

}
