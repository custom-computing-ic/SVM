import java.util.ArrayList;
import java.util.List;

import com.maxeler.maxcompiler.v2.kernelcompiler.KernelLib;
import com.maxeler.maxcompiler.v2.kernelcompiler.RoundingMode;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.Counter;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.WrapMode;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.memory.Memory;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Stream.OffsetExpr;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Mem.RamWriteMode;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.Reductions;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.KernelMath;
import com.maxeler.maxcompiler.v2.utils.MathUtils;

import maxpower.ConstDenominator;


/**
 * This class maintains Matrix R 
 *	- Store R in small 1-by-blockDim blocks for parallelised access
 *	- Support Beta Calculation, R Initialisation, R Enlarge and R Shrink
 *
 *
 * @author Patrick Shao
 *
 * @param <numBlocks> Number of blocks in each 1D Dimension - WinSize = numBlocks * blockDim
 * @param <blockDim>  Number of elements in each block
 * @param <SSize> Current SSize
 * @param <SMaskIDToRemove>  SMask index of item to be removed
 * @param <betaX> REnlarge: betaX = betaBlock[XAddr] - width = numBlocks - inner loop
 * @param <betaY> REnlarge: betaY = betaBlock[YSelectAddr] - width = numBlocks - outer loop
 * @param <gammaInv> REnlarge: gammaInv = 1/gamma[k]
 * @param <beginRInit> Trigger Signal for RInit
 * @param <beginBetaCalc> Trigger Signal for Beta Calculation
 * @param <beginREnlarge> Trigger Signal for REnlarge
 * @param <beginRShrink>	Trigger Signal for RShrink
 * 
 */


class RMem extends KernelLib{

	private DFEVector<DFEVector<DFEVar>> BetaCalcVec;
	
	public DFEVector<DFEVector<DFEVar>> getBetaCalcVec() 	{return BetaCalcVec;}

	RMem ( 	KernelLib owner,
			int numBlocks,
			int blockDim,
			DFEVar SSize, 				// Current SSize
			DFEVar SMaskIDToRemove,  		// SMask index of item to be removed
			DFEVector<DFEVar> betaX, 	// REnlarge: betaX = betaBlock[XAddr] - width = numBlocks - inner loop
			DFEVector<DFEVar> betaY, 	// REnlarge: betaY = betaBlock[YSelectAddr] - width = numBlocks - outer loop
			DFEVar gammaInv, 			// REnlarge: gammaInv = 1/gamma[k]
			DFEVar beginRInit, 			// Trigger Signal for RInit
			DFEVar beginBetaCalc, 		// Trigger Signal for Beta Calculation
			DFEVar beginREnlarge, 		// Trigger Signal for REnlarge
			DFEVar beginRShrink) 			// Trigger Signal for RShrink

	{

		super(owner);
		
		/////////////////////// Definitions ///////////////////////
				
		int WinSize = numBlocks * blockDim;
		DFEVectorType<DFEVar> numBlocksVec = new DFEVectorType<DFEVar>(Def.CalcType, numBlocks);
		DFEVectorType<DFEVar> blockDimDataVec = new DFEVectorType<DFEVar>(Def.CalcType, blockDim);
		DFEVectorType<DFEVar> blockDimAddrVec = new DFEVectorType<DFEVar>(dfeUInt(MathUtils.bitsToAddress(blockDim)), blockDim);
		DFEVectorType<DFEVar> blockDimBoolVec = new DFEVectorType<DFEVar>(dfeBool(), blockDim);
		DFEVar XAddr = dfeUInt(MathUtils.bitsToAddress(blockDim)).newInstance(this);
		DFEVar YAddr = dfeUInt(MathUtils.bitsToAddress(blockDim)).newInstance(this);

                
		/////////////////////// Beta Calc ///////////////////////

		// BetaCalcVec[Y][X]
		DFEVector<DFEVector<DFEVar>> BetaCalcVec = (new DFEVectorType<DFEVector<DFEVar>>(numBlocksVec, numBlocks)).newInstance(this);


 		/////////////////////// RInit ///////////////////////

		// Control Signal for RInit - blockDim cycles
		AddrGenerator RInitCounter = new AddrGenerator(owner, 1, blockDim, beginRInit);
		DFEVar isInit = RInitCounter.isValid();

		
 		/////////////////////// REnlarge ///////////////////////
 		
 		// Base and Offset Address of Edge
 		ConstDenominator.ConstDivModResult EdgeDivModResult = ConstDenominator.divMod(SSize+1, blockDim);
 		DFEVar REnlargeEdgeBaseAddr = EdgeDivModResult.getQuotient();
 		DFEVar REnlargeEdgeOffsetAddr = EdgeDivModResult.getRemainder();
		
		// Control Signal for REnlarge - blockDim^2 cycles
		AddrGenerator REnlargeCounter = new AddrGenerator(owner, 1, blockDim*blockDim, beginREnlarge);
		DFEVar isEnlarging = REnlargeCounter.isValid();


		/////////////////////// RShrink ///////////////////////
		
		// Control Signal for RShrink -  cycles
		int RShrinkCycles = blockDim*blockDim + 3*blockDim + 150;
                AddrGenerator RShrinkCounter = new AddrGenerator(owner, 1, RShrinkCycles, beginRShrink);
                DFEVar RShrinkCount = RShrinkCounter.getAddr();

		// Base and Offset Address of Edge
 		ConstDenominator.ConstDivModResult PosDivModResult = ConstDenominator.divMod(SMaskIDToRemove+1, blockDim);
 		DFEVar RShrinkPosBaseAddr = PosDivModResult.getQuotient();
 		DFEVar RShrinkPosOffsetAddr = PosDivModResult.getRemainder();
		

		/////////////////////// RShrink - Fetching ///////////////////////
				
		// Control Signal for Fetching
		DFEVar beginFetch = beginRShrink;
		AddrGenerator FetchingCounter = new AddrGenerator(owner, 1, blockDim, beginFetch);
		DFEVar isFetching = FetchingCounter.isValid();
		
		// XElem - prefetched R[k][:] for RShrink
		DFEVector<DFEVar> XElem = numBlocksVec.newInstance(this);
		DFEVector<DFEVar> toXBuffer = numBlocksVec.newInstance(this);
		for (int i=0; i<numBlocks; ++i) {
			Memory<DFEVar> XBuffer = mem.alloc(Def.CalcType, blockDim);
			XElem[i] <== XBuffer.port(XAddr, toXBuffer[i], isFetching, RamWriteMode.READ_FIRST);
		}

		// YElem - prefetched R[:][k] for RShrink
		DFEVector<DFEVar> YElem = numBlocksVec.newInstance(this);
		DFEVector<DFEVar> toYBuffer = numBlocksVec.newInstance(this);
		for (int i=0; i<numBlocks; ++i) {
			Memory<DFEVar> YBuffer = mem.alloc(Def.CalcType, blockDim);
			YElem[i] <== YBuffer.read(YAddr);
			YBuffer.write(XAddr, toYBuffer[i], isFetching);
		}
		
		// 1/R[k][k] for RShrink
		DFEVar toKElemInvStreamHold = 1.0 / control.mux(RShrinkPosBaseAddr, toXBuffer.getElementsAsList());
		DFEVar enKElemInvStreamHold = (XAddr === RShrinkPosOffsetAddr) & isFetching;
		DFEVar KElemInv = Reductions.streamHold(toKElemInvStreamHold, enKElemInvStreamHold);		
		
		
		/////////////////////// RShrink - Shrinking ///////////////////////
		
		// Control Signal for Shrinking
		DFEVar beginShrink = (RShrinkCount === blockDim + 50);
		AddrGenerator ShrinkCounter = new AddrGenerator(owner, 1, blockDim*blockDim, beginShrink);
		DFEVar isShrinking = ShrinkCounter.isValid();


		/////////////////////// RShrink - UpShifting ///////////////////////	
		
		// Control Signal for UpShifting
		DFEVar beginUpShift = (RShrinkCount === blockDim*blockDim + blockDim + 120);
		AddrGenerator UpShiftCounter = new AddrGenerator(owner, 1, blockDim, beginUpShift);
		DFEVar isUpShifting = UpShiftCounter.isValid();


		/////////////////////// RShrink - LeftShifting ///////////////////////	
		
		// Control Signal for LeftShifting
		DFEVar beginLeftShift = (RShrinkCount === blockDim*blockDim + 2*blockDim + 130);
		AddrGenerator LeftShiftCounter = new AddrGenerator(owner, 1, blockDim, beginLeftShift);
		DFEVar isLeftShifting = LeftShiftCounter.isValid();


		/////////////////////// Address ///////////////////////
		
    		// XAddr - inner loop
		DFEVar XAddrCounterReset = beginBetaCalc | beginRInit | beginREnlarge | beginFetch | beginShrink | beginUpShift | beginLeftShift;
                Count.Params XAddrCounterParam = control.count.makeParams(MathUtils.bitsToAddress(blockDim))
                							.withInitValue(0)
                							.withMax(blockDim)
                							.withWrapMode(WrapMode.COUNT_LT_MAX_THEN_WRAP)
                							.withReset(XAddrCounterReset);
                Counter XAddrCounter = control.count.makeCounter(XAddrCounterParam);
                XAddr <== XAddrCounter.getCount();
                
                // YAddr - outer loop
               	DFEVar YAddrCounterReset = XAddrCounterReset;
                Count.Params YAddrCounterParam = control.count.makeParams(MathUtils.bitsToAddress(blockDim))
                							.withInitValue(0)
                							.withMax(blockDim)
                							.withEnable(XAddrCounter.getWrap())
                							.withWrapMode(WrapMode.COUNT_LT_MAX_THEN_WRAP)
                							.withReset(YAddrCounterReset);
                Counter YAddrCounter = control.count.makeCounter(YAddrCounterParam);
                YAddr <== isFetching ? RShrinkPosOffsetAddr : YAddrCounter.getCount();
		

		/////////////////////// R Blocks ///////////////////////

		// Outputs from block
		DFEVector<DFEVar> [][] toLeftBlock = new DFEVector [numBlocks][numBlocks];
		DFEVector<DFEVar> [][] portData = new DFEVector [numBlocks][numBlocks];
		DFEVar [][] toUpBlock = new DFEVar [numBlocks][numBlocks];

		// RShrinkDatafromDown	
		DFEVar [][] RShrinkDatafromDown = new DFEVar [numBlocks][numBlocks];
		for (int i=0; i<numBlocks; ++i) {
			for (int j=0; j<numBlocks; ++j) RShrinkDatafromDown[i][j] = Def.CalcType.newInstance(this);
		}
		
		// RShrinkDatafromRight
		DFEVector<DFEVar> [][] RShrinkDatafromRight = new DFEVector [numBlocks][numBlocks];
		for (int i=0; i<numBlocks; ++i) {
			for (int j=0; j<numBlocks; ++j) RShrinkDatafromRight[i][j] = blockDimDataVec.newInstance(this);
		}
		

		// RBlocks
		RBlock [][] RGrid = new RBlock[numBlocks][numBlocks];
		for (int X=0; X<numBlocks; ++X) {
			for (int Y=0; Y<numBlocks; ++Y) {
				RGrid[X][Y] = new RBlock (owner, X, Y, blockDim,
				REnlargeEdgeBaseAddr, REnlargeEdgeOffsetAddr, RShrinkPosBaseAddr, RShrinkPosOffsetAddr,
				betaX[X], betaY[Y], gammaInv, XElem[X], YElem[Y], KElemInv, RShrinkDatafromDown[X][Y], RShrinkDatafromRight[X][Y],
				XAddr, YAddr, isInit, isEnlarging, isFetching, isShrinking, isUpShifting, isLeftShifting);
				
				toUpBlock[X][Y] = RGrid[X][Y].getDataToUpBlock();
				toLeftBlock[X][Y] = RGrid[X][Y].getReadVec();
				portData[X][Y] = RGrid[X][Y].getPortVec();
				BetaCalcVec[Y][X] <== RGrid[X][Y].getCurXYItem();
			}
		}		
		
		/////////////////////// Wiring Outputs ///////////////////////
		
		// XElem
		toXBuffer <== control.mux(RShrinkPosBaseAddr, BetaCalcVec.getElementsAsList());
		
		// YElem
		for (int Y=0; Y<numBlocks; ++Y) {
			List<DFEVector<DFEVar>> toXmux = new ArrayList<DFEVector<DFEVar>>();
			for (int X=0; X<numBlocks; ++X) toXmux.add(portData[X][Y]);
			DFEVector<DFEVar> toYmux = control.mux(RShrinkPosBaseAddr, toXmux);
			toYBuffer[Y] <== control.mux(XAddr, toYmux.getElementsAsList());
		}

		// Zero Vector
		DFEVector<DFEVar> blockDimZeroDataVec = blockDimDataVec.newInstance(this);
		for (int i=0; i<blockDim; ++i) blockDimZeroDataVec[i] <== constant.var(Def.CalcType, 0);
		
		// RShrinkDatafromDown and RShrinkDatafromRight
		for (int X=0; X<numBlocks-1; ++X) {
			for (int Y=0; Y<numBlocks-1; ++Y) {
				RShrinkDatafromDown[X][Y] <== toUpBlock[X][Y+1];
				RShrinkDatafromRight[X][Y] <== Reductions.streamHold(toLeftBlock[X+1][Y], beginLeftShift);
			}
			RShrinkDatafromDown[X][numBlocks-1] <== constant.var(Def.CalcType, 0);
			RShrinkDatafromRight[X][numBlocks-1] <== Reductions.streamHold(toLeftBlock[X+1][numBlocks-1], beginLeftShift);
		}
		for (int Y=0; Y<numBlocks-1; ++Y) {
			RShrinkDatafromDown[numBlocks-1][Y] <== toUpBlock[numBlocks-1][Y+1];
			RShrinkDatafromRight[numBlocks-1][Y] <== blockDimZeroDataVec;
		}
		RShrinkDatafromDown[numBlocks-1][numBlocks-1] <== constant.var(Def.CalcType, 0);
		RShrinkDatafromRight[numBlocks-1][numBlocks-1] <== blockDimZeroDataVec;

	
	}

	private class RBlock extends KernelLib {
	
		private final DFEVector<DFEVar> readVec;
		private final DFEVector<DFEVar> portVec;
		private final DFEVar toUpBlock;
		private final DFEVar curXYItem;

		public DFEVector<DFEVar> getReadVec() 		{return readVec;}
		public DFEVector<DFEVar> getPortVec() 		{return portVec;}
		public DFEVar getDataToUpBlock() 		{return toUpBlock;}
		public DFEVar getCurXYItem() 		{return curXYItem;}

		RBlock ( 	KernelLib owner, 
				int X, 
				int Y,
				int blockDim, 
				DFEVar REnlargeEdgeBaseAddr, 					// REnlarge: Base Address of the Edge
				DFEVar REnlargeEdgeOffsetAddr, 				// REnlarge: Offset Address of the Edge
				DFEVar RShrinkPosBaseAddr, 					// RShrink: Base Address of Remove Position
				DFEVar RShrinkPosOffsetAddr, 					// RShrink: Offset Address of Remove Position
				DFEVar betaX, 								// REnlarge: beta[X]
				DFEVar betaY, 								// REnlarge: beta[Y]
				DFEVar gammaInv, 							// REnlarge: 1/gamma_k
				DFEVar XElem, 								// RShrink: Elem from Vertical Line
				DFEVar YElem, 								// RShrink: Elem from Horizontal Line
				DFEVar KElemInv, 								// RShrink: 1/R[k][k]
				DFEVar RShrinkDatafromDown, 					// Data for RShrink - UpShifting
				DFEVector<DFEVar> RShrinkDatafromRight, 		// Data for RShrink - LeftShifting
				DFEVar XAddr, 								// XAddr - inner loop
				DFEVar YAddr, 								// YAddr - outer loop
				DFEVar isInit, 								// Control Variable for RInit
				DFEVar isEnlarging, 							// Control Variable for REnlarge
				DFEVar isFetching,  							// Control Variable for RShrink - Fetching
				DFEVar isShrinking,  							// Control Variable for RShrink - Shrinking
				DFEVar isUpShifting, 							// Control Variable for RShrink - UpShifting
				DFEVar isLeftShifting) 							// Control Variable for RShrink - LeftShifting

		{
			
			super(owner);
			
			DFEVectorType<DFEVar> blockDimDataVec = new DFEVectorType<DFEVar>(Def.CalcType, blockDim);
			DFEVectorType<DFEVar> blockDimAddrVec = new DFEVectorType<DFEVar>(dfeUInt(MathUtils.bitsToAddress(blockDim)), blockDim);
			DFEVectorType<DFEVar> blockDimBoolVec = new DFEVectorType<DFEVar>(dfeBool(), blockDim);
			
			
			/////////////////////// Memory - Read ///////////////////////
			
			readVec = blockDimDataVec.newInstance(this);
			portVec = blockDimDataVec.newInstance(this);
			ArrayList<Memory<DFEVar>> Block = new ArrayList<Memory<DFEVar>>();
			for (int i=0; i<blockDim; ++i) {
				Block.add(i, mem.alloc(Def.CalcType, blockDim));
				readVec[i] <== Block.get(i).read(XAddr);
			}
			curXYItem = control.mux(YAddr, readVec.getElementsAsList());
			toUpBlock = portVec[0];


			/////////////////////// RInit ///////////////////////
			
			// Parallel Write - blockDim cycles
			// Write Data - PortAddr = XAddr
			DFEVector<DFEVar> RInitPortData = blockDimDataVec.newInstance(this);
			DFEVector<DFEVar> RInitPortEn = blockDimBoolVec.newInstance(this);
			for (int i=0; i<blockDim; ++i) {
				if ((Y==0)&&(i==0)) RInitPortData[i] <== (XAddr===0) ? constant.var(Def.CalcType, -1) : constant.var(Def.CalcType, 1);
				else RInitPortData[i] <== (XAddr===0) ? constant.var(Def.CalcType, 1) : constant.var(Def.CalcType, 0);
				RInitPortEn[i] <== isInit;
			}


			/////////////////////// REnlarge ///////////////////////
			
			// Sequential Write - blockDim^2 cycles
			// Judge the location
			DFEVar isREnlargeXEdge = (X === REnlargeEdgeBaseAddr) & (XAddr === REnlargeEdgeOffsetAddr);
			DFEVar isREnlargeYEdge = (Y === REnlargeEdgeBaseAddr) & (YAddr === REnlargeEdgeOffsetAddr);
			DFEVar isREnlargeCorner = isREnlargeXEdge & isREnlargeYEdge;
			
			// Data to Write
			DFEVar REnlargeInnerData = curXYItem + betaX * betaY * gammaInv;
			DFEVar REnlargeXEdgeData = betaY * gammaInv;
			DFEVar REnlargeYEdgeData = betaX * gammaInv;
			DFEVar REnlargeCornerData = gammaInv;
			DFEVar sharedREnlargePortData = isREnlargeCorner ? REnlargeCornerData : (isREnlargeXEdge ? REnlargeXEdgeData : (isREnlargeYEdge ? REnlargeYEdgeData : REnlargeInnerData));

			// EnWrite - PortAddr = XAddr
			DFEVector<DFEVar> REnlargePortData = blockDimDataVec.newInstance(this);
			DFEVector<DFEVar> REnlargePortEn = blockDimBoolVec.newInstance(this);
			for (int i=0; i<blockDim; ++i) {
				REnlargePortData[i] <== sharedREnlargePortData;
				REnlargePortEn[i] <== (YAddr === i) & isEnlarging;
			}


			/////////////////////// RShrink ///////////////////////

			// blockDim cycles
			// Fetching
			DFEVector<DFEVar> FetchPortAddr = blockDimAddrVec.newInstance(this);
			for (int i=0; i<blockDim; ++i) {
				FetchPortAddr[i] <== ((Y === RShrinkPosBaseAddr) & (i === RShrinkPosOffsetAddr)) ? XAddr : RShrinkPosOffsetAddr;
			}
			
			// Sequential Write - blockDim^2 cycles
			// Shrinking - PortAddr = XAddr
			DFEVar sharedShrinkPortData = curXYItem - XElem * YElem * KElemInv;
			DFEVector<DFEVar> ShrinkPortData = blockDimDataVec.newInstance(this);
			DFEVector<DFEVar> ShrinkPortEn = blockDimBoolVec.newInstance(this);
			for (int i=0; i<blockDim; ++i) {
				ShrinkPortData[i] <== sharedShrinkPortData;
				ShrinkPortEn[i] <== (YAddr === i) & isShrinking;
			}
			
			// There is a latency of calculating ShrinkPortData - must ensure the result is written to the memory before shifting.
			// Therefore, blockDim should be greater than that latency, or we need to wait for a number of cycles.

			// blockDim cycles
			// Up Shifting - PortAddr = XAddr
			DFEVector<DFEVar> UpShiftPortData = blockDimDataVec.newInstance(this);
			DFEVector<DFEVar> UpShiftPortEn = blockDimBoolVec.newInstance(this);
			for (int i=0; i<blockDim; ++i) {
				if (i==(blockDim-1)) UpShiftPortData[i] <== RShrinkDatafromDown;
				else UpShiftPortData[i] <== portVec[i+1];
				UpShiftPortEn[i] <== ((Y>RShrinkPosBaseAddr)|((Y===RShrinkPosBaseAddr)&(i>=RShrinkPosOffsetAddr))) & isUpShifting;
			}

			// blockDim cycles
			// Left Shifting
			DFEVar sharedLeftShiftPortAddr = stream.offset(XAddr, -1);
			DFEVar sharedLeftShiftPortEn = stream.offset(isLeftShifting, -1) & ((X>RShrinkPosBaseAddr) | ((X===RShrinkPosBaseAddr) & (sharedLeftShiftPortAddr >= RShrinkPosOffsetAddr)) );
			DFEVector<DFEVar> LeftShiftPortData = blockDimDataVec.newInstance(this);
			DFEVector<DFEVar> LeftShiftPortEn = blockDimBoolVec.newInstance(this);
			for (int i=0; i<blockDim; ++i) {
				LeftShiftPortData[i] <== (sharedLeftShiftPortAddr === (blockDim-1)) ? RShrinkDatafromRight[i] : readVec[i];
				LeftShiftPortEn[i] <== sharedLeftShiftPortEn;
			}

			// RShrink - Overall
			DFEVector<DFEVar> FetchLeftShiftPortAddr = blockDimAddrVec.newInstance(this);
			DFEVector<DFEVar> RShrinkPortData = blockDimDataVec.newInstance(this);
			DFEVector<DFEVar> RShrinkPortEn = blockDimBoolVec.newInstance(this);			
			for (int i=0; i<blockDim; ++i) {
				FetchLeftShiftPortAddr[i] <== isFetching ? FetchPortAddr[i] : sharedLeftShiftPortAddr;
				RShrinkPortData[i] <== isShrinking ? ShrinkPortData[i] : (isUpShifting ? UpShiftPortData[i] : LeftShiftPortData[i]);
				RShrinkPortEn[i] <== ShrinkPortEn[i] | UpShiftPortEn[i] | LeftShiftPortEn[i];
			}


			/////////////////////// Memory - Write ///////////////////////
			
			for (int i=0; i<blockDim; ++i) {
				// Stream Offset
				OffsetExpr RBlockOffset = stream.makeOffsetAutoLoop("OffsetRBlockX"+X+"Y"+Y+"Row"+i);
				// Write Data
				DFEVar PortDataUnOffseted = isInit ? RInitPortData[i] : (isEnlarging ? REnlargePortData[i] : RShrinkPortData[i]);
				DFEVar PortData = stream.offset(PortDataUnOffseted, -RBlockOffset);
				// Write Addr
				DFEVar PortAddrUnOffseted = (isFetching | stream.offset(isLeftShifting, -1)) ? FetchLeftShiftPortAddr[i] : XAddr;
				DFEVar PortAddr = stream.offset(PortAddrUnOffseted, -RBlockOffset);
				// Write Enable
				DFEVar PortWrEnUnOffseted = RInitPortEn[i] | REnlargePortEn[i] | RShrinkPortEn[i];
				DFEVar PortWrEn = stream.offset(PortWrEnUnOffseted, -RBlockOffset);
				// Write - READ_FIRST is required by UpShifting
				portVec[i] <== Block.get(i).port(PortAddr, PortData, PortWrEn, RamWriteMode.READ_FIRST);
			}

		}	
	
	}

}
