import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.SMIO;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.KernelMath;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Stream.OffsetExpr;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.memory.Queue;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.Reductions;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.memory.Memory;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Mem.RamWriteMode;
import com.maxeler.maxcompiler.v2.utils.MathUtils;

import maxpower.ZeroLatencyInput;
import maxpower.KernelBinaryOp.Add;
import maxpower.TreeReduce;

class SVMKernel extends Kernel {

	// Dimension Parameters
	private final int numBlocks;
	private final int blockDim;
	private final int WinSize;
	
	// Length of Input Stream
	private final int streamLength;

	SVMKernel(KernelParameters parameters, int numBlocks_IN, int blockDim_IN, int streamLength_IN) {
	
		////////////////////////// Parameters /////////////////////////
		
		super(parameters);
		
		// Parameters
		numBlocks 	= numBlocks_IN;
		blockDim 	= blockDim_IN;
		WinSize 		= numBlocks_IN * blockDim_IN;
		streamLength = streamLength_IN;
		
		// Types
		DFEType BaseAddrType 	= dfeUInt(MathUtils.bitsToAddress(numBlocks));
		DFEType OffsetAddrType 	= dfeUInt(MathUtils.bitsToAddress(blockDim));
		DFEType PosType 			= dfeUInt(MathUtils.bitsToAddress(WinSize));
		DFEType FlagType 		= dfeUInt(4);
		DFEType BoolType			= dfeBool();
		
		
		////////////////////////// From State Machine /////////////////////////
		
		SMIO SM = addStateMachine("SVMControl", new SVMStateMachine(this, numBlocks, blockDim, WinSize));
		
		// Control Signal for Input Stream Xc
		DFEVar EnInput 				= SM.getOutput("EnInput");
		
		// INC or DEC
		DFEVar isInc 					= SM.getOutput("isInc");		
		
		// Size
		DFEVar SSize 				= SM.getOutput("SSize");
		DFEVar NSize 				= SM.getOutput("NSize");
		DFEVar isEmptyS 				= (SSize === 0);

		// QFetch: Trigger, Status and Write Address
		DFEVar beginFetchQ 		 	= SM.getOutput("beginFetchQ");
		DFEVar isFetchingQ 		 	= SM.getOutput("isFetchingQ");
		DFEVar QBufWriteOffsetAddr 	= SM.getOutput("QBufWriteOffsetAddr");
		
		// Base and Offset Addresses of Xc, SMask, NMask. Index of SMask and NMask
		DFEVar BaseAddrXc 			= SM.getOutput("BaseAddrXc");
		DFEVar OffsetAddrXc 			= SM.getOutput("OffsetAddrXc");
		DFEVar GroupIndexXc 			= SM.getOutput("GroupIndexXc");
		DFEVar BaseAddrSMask 		= SM.getOutput("BaseAddrSMask");
		DFEVar OffsetAddrSMask 		= SM.getOutput("OffsetAddrSMask");
		DFEVar IndexSMask			= SM.getOutput("IndexSMask");
		DFEVar GroupIndexSMask 		= SM.getOutput("GroupIndexSMask");
		DFEVar SMaskValid 			= SM.getOutput("SMaskValid");
		DFEVar BaseAddrNMask 		= SM.getOutput("BaseAddrNMask");
		DFEVar OffsetAddrNMask 		= SM.getOutput("OffsetAddrNMask");
		DFEVar IndexNMask 			= SM.getOutput("IndexNMask");
		DFEVar GroupIndexNMask 		= SM.getOutput("GroupIndexNMask");
		DFEVar NMaskValid 	 		= SM.getOutput("NMaskValid");
		
		// BookKeeping
		DFEVar beginBookKeeping 		= SM.getOutput("beginBookKeeping");
		DFEVar BookKeepingSel 		= SM.getOutput("BookKeepingSel");
		DFEVar BookKeepingValid 		= SM.getOutput("BookKeepingValid");
		DFEVar beginBetaCalc 			= SM.getOutput("beginBetaCalc");
		DFEVar beginBookKeeping_S 	= SM.getOutput("beginBookKeeping_S");
		DFEVar isBookKeeping_N 		= SM.getOutput("isBookKeeping_N");
		
		// GammaCalc
		DFEVar beginGammaCCalc 		= SM.getOutput("beginGammaCCalc");
		DFEVar isGammaCCalculating 	= SM.getOutput("isGammaCCalculating");
		DFEVar beginGammaVCalc 		= SM.getOutput("beginGammaVCalc");
		DFEVar isGammaVCalculating 	= SM.getOutput("isGammaVCalculating");
		
		// Updating
		DFEVar beginUpdate 			= SM.getOutput("beginUpdate");		
		DFEVar isUpdating 			= SM.getOutput("isUpdating");
		
		// Moving Data Items
		DFEVar beginMoveFetchQ 		= SM.getOutput("beginMoveFetchQ");
		DFEVar isMoveFetchingQ 		= SM.getOutput("isMoveFetchingQ");
		DFEVar beginGammaKCalc 		= SM.getOutput("beginGammaKCalc");
		DFEVar isGammaKCalculating 	= SM.getOutput("isGammaKCalculating");
		DFEVar beginGammaCREnlarge 	= SM.getOutput("beginGammaCREnlarge");
		DFEVar beginRInit 			= SM.getOutput("beginRInit");
		DFEVar beginRShrink 			= SM.getOutput("beginRShrink");
		DFEVar isRShrinking 			= SM.getOutput("isRShrinking");
		DFEVar beginThetaKUpdate 	= SM.getOutput("beginThetaKUpdate");
		DFEVar isThetaKUpdating 		= SM.getOutput("isThetaKUpdating"); 

		
		////////////////////////// To State Machine /////////////////////////		
		
		// Finish Trigger
		DFEVar hasFinished = BoolType.newInstance(this);
		DFEVar hasQUpdateFinished = BoolType.newInstance(this);
		DFEVar hasBetaCalcFinished = BoolType.newInstance(this);
		DFEVar hasGammaVCalcFinished = BoolType.newInstance(this);
		DFEVar hasthetaKUpdateFinished = BoolType.newInstance(this);
		SM.connectInput("hasFinished", hasFinished);
		SM.connectInput("hasQUpdateFinished", hasQUpdateFinished);
		SM.connectInput("hasBetaCalcFinished", hasBetaCalcFinished);
		SM.connectInput("hasGammaVCalcFinished", hasGammaVCalcFinished);
		SM.connectInput("hasthetaKUpdateFinished", hasthetaKUpdateFinished);

		// BookKeeping
		DFEVar BookKeepingFlagOffseted = FlagType.newInstance(this);
		DFEVar BookKeepingIndexOffseted = PosType.newInstance(this);
		SM.connectInput("BookKeepingFlag", BookKeepingFlagOffseted);
		SM.connectInput("BookKeepingIndex", BookKeepingIndexOffseted);
		

		////////////////////////// Input /////////////////////////

		// Xc FIFO
		DFEVector<DFEVar> Xc_IN = ZeroLatencyInput.input("Xc", Def.DataVecType, EnInput, constant.var(dfeUInt(32), streamLength));
		Queue<DFEVector<DFEVar>> XcQueue = mem.queue(Def.DataVecType, 2);
		XcQueue.insert(Xc_IN, EnInput);
		DFEVector<DFEVar> Xc = XcQueue.remove(EnInput);
		
		// Yc FIFO
		DFEVar Yc_IN = ZeroLatencyInput.input("Yc", Def.DataYType, EnInput, constant.var(dfeUInt(32), streamLength));
		Queue<DFEVar> YcQueue = mem.queue(Def.DataYType, 2);
		YcQueue.insert(Yc_IN, EnInput);
		DFEVar Yc = YcQueue.remove(EnInput);


		////////////////////////// Handling New item Xc /////////////////////////
		
		// Counting Cycles from the Tick of Xc arrival
		//     EnInput: 0, 0, 1, 0, 0, 0, 0, ...,                  0, 0, 0, 0, 0...
		// blockAddr: 0, 0, 0, 1, 2, 3, 4, ..., blockDim-1, 0, 0, 0, 0...
		//          valid: 0, 0, 1, 1, 1, 1, 1, ...,                 1, 0, 0, 0, 0...
		AddrGenerator blockAddrGen = new AddrGenerator(this, 1, blockDim, EnInput);
		DFEVar isProcessingNewXc = blockAddrGen.isValid();

		// dataX
		dataXBlock [] DataXBlock = new dataXBlock[numBlocks];
		DFEVector<DFEVector<DFEVar>> dataX = (new DFEVectorType<DFEVector<DFEVar>>(Def.DataVecType, numBlocks)).newInstance(this);
		for (int i=0; i<numBlocks; ++i) {
			DataXBlock[i] = new dataXBlock(this, i, blockDim, Def.DataDim, Xc, BaseAddrXc, OffsetAddrXc, EnInput);
			dataX[i] <== DataXBlock[i].getData();
		}

		// dataY
		DFEVar YPortAddr = isProcessingNewXc ? GroupIndexXc : GroupIndexSMask;
		Memory<DFEVar> dataYBlock = mem.alloc(Def.DataYType, WinSize);
		dataYBlock.mapToCPU("dataY");
		DFEVar dataY = dataYBlock.port(YPortAddr, Yc, EnInput, RamWriteMode.WRITE_FIRST);
		
		// Kernel Calc
		DFEVector<DFEVar> KernelVec = (new DFEVectorType<DFEVar>(Def.QType, numBlocks)).newInstance(this);
		for (int i=0; i<numBlocks; ++i) {
			KernelVec[i] <== RBFKernel(Xc, dataX[i]);
		}
		
		// Matrix Q
		// NOTE: hXi[k] calculation is done during RShrink process, so Row Addr set to SMask during RShrink
		DFEVar BaseAddrColG 		= beginGammaKCalc ? BaseAddrNMask : ((beginGammaVCalc | beginGammaCCalc) ? BaseAddrXc : BaseAddrSMask);
		DFEVar OffsetAddrColG 	= beginGammaKCalc ? OffsetAddrNMask : ((beginGammaVCalc | beginGammaCCalc) ? OffsetAddrXc : OffsetAddrSMask);
		DFEVar BaseAddrCol 		= (isFetchingQ | isMoveFetchingQ) ? BaseAddrSMask 	: BaseAddrColG;
		DFEVar OffsetAddrCol 		= (isFetchingQ | isMoveFetchingQ) ? OffsetAddrSMask 	: OffsetAddrColG;
		DFEVar BaseAddrRow 		= isRShrinking ? BaseAddrSMask   : ((isGammaVCalculating | isGammaKCalculating | isMoveFetchingQ) ? BaseAddrNMask : BaseAddrXc);
		DFEVar OffsetAddrRow 		= isRShrinking ? OffsetAddrSMask : ((isGammaVCalculating | isGammaKCalculating | isMoveFetchingQ) ? OffsetAddrNMask : OffsetAddrXc);
		DFEVar MatQEnWrite 		= isProcessingNewXc;
		DFEVar MatQEnIterate 		= (EnInput | beginRShrink);
		QMem MatrixQ = new QMem(this, numBlocks, blockDim, KernelVec, BaseAddrRow, OffsetAddrRow, MatQEnWrite, MatQEnIterate, BaseAddrCol, OffsetAddrCol);
		DFEVector<DFEVar> QVector = MatrixQ.getQValVec();
		DFEVar QVal = MatrixQ.getQVal();
		DFEVar hasQUpdateFinishedFromQMem = MatrixQ.hasFinished();
		
		
		// theta - individual write, parallel and individual access
		DFEVar thetaIn 				= Def.thetaType.newInstance(this);
		DFEVar thetaWrBaseAddr 		= BaseAddrType.newInstance(this);
		DFEVar thetaWrOffsetAddr 		= OffsetAddrType.newInstance(this);
		DFEVar thetaRdBaseAddr 		= (beginBookKeeping | beginUpdate) ? BaseAddrXc 	: BaseAddrSMask;
		DFEVar thetaRdOffsetAddr 		= (beginBookKeeping | beginUpdate) ? OffsetAddrXc 	: OffsetAddrSMask;
		DFEVar thetaImmediateWrite 	= BoolType.newInstance(this);
		DFEVar EnThetaIterateWrite 	= isProcessingNewXc;
		DFEVar EnThetaIterate 			= (EnInput | beginRShrink);
		dataBlock1D thetaBlock = new dataBlock1D (this, "theta", numBlocks, blockDim, thetaIn, thetaWrBaseAddr, thetaWrOffsetAddr, thetaRdBaseAddr, thetaRdOffsetAddr, thetaImmediateWrite, EnThetaIterateWrite, EnThetaIterate, beginThetaKUpdate, isThetaKUpdating);
		DFEVector<DFEVar> thetaVector = thetaBlock.getDataVec();
		DFEVar thetaSeq = thetaBlock.getDataVal();
		DFEVar thetaKUpdateFinishedFromThetaBlock = thetaBlock.hasThetaKUpdateFinished();

		
		// b
		Memory<DFEVar> bMem = mem.alloc(Def.DataYType, 2);
		bMem.mapToCPU("b");
		DFEVar b = bMem.read(constant.var(dfeUInt(1),0));
			
		
		// hXi - hCalc needs blockDim cycles, WrEn enables write results to WrAddr at the end of calculation
		DFEVar beginhCalc 		= (EnInput | beginRShrink);
		DFEVar hXiRdAddr 		= (beginBookKeeping | beginUpdate) ? GroupIndexXc : GroupIndexNMask;
		DFEVar hXiWrAddr 		= PosType.newInstance(this);
		DFEVar hXiWrData 		= Def.hXiType.newInstance(this);
		DFEVar hXiWrEn 			= BoolType.newInstance(this);
		hCalc hXiCalc = new hCalc(this, numBlocks, blockDim, QVector, thetaVector, b, dataY, beginhCalc, hXiRdAddr, hXiWrAddr, hXiWrData, hXiWrEn);
		DFEVar hXi = hXiCalc.getMemData().cast(Def.BookKeepingType);
		DFEVar hXiCalcResult = hXiCalc.getCalcResult();
		DFEVar hXiCalcResultValid = hXiCalc.isValid();
		DFEVar hXcValid = hXiCalcResultValid & isProcessingNewXc;
		DFEVar XcJoinR = (KernelMath.abs(hXiCalcResult)<Def.ep) & hXcValid;
	

		// q
		// TODO: q is different for DEC
		DFEVar toqStreamHold = (hXiCalcResult > 0) ? constant.var(dfeInt(2), -1) : constant.var(dfeInt(2), 1);
		DFEVar q = Reductions.streamHold(toqStreamHold, hXcValid);


		////////////////////////// Bookkeeping Preparation /////////////////////////

		// QBuffer
		DFEVar beginQBufRead 	= beginBetaCalc;
		DFEVar QBufBeginFetch 	= (beginFetchQ | beginMoveFetchQ);
		DFEVar QBufEnWrite 		= (isFetchingQ | isMoveFetchingQ);
		QBuffer QBuf = new QBuffer (this, numBlocks, blockDim, SSize, QVal, QBufBeginFetch, QBufWriteOffsetAddr, QBufEnWrite, beginQBufRead);
		DFEVector<DFEVar> QBufVec = QBuf.getData();

		// beta Vector
		DFEVector<DFEVar> betaX = (new DFEVectorType<DFEVar>(Def.betaType, numBlocks)).newInstance(this);
		DFEVector<DFEVar> betaY = (new DFEVectorType<DFEVar>(Def.betaType, numBlocks)).newInstance(this);

		// RMem
		DFEVar SMaskIDToRemove 	= PosType.newInstance(this);
		DFEVar gammaInv 		= Def.RType.newInstance(this);
		DFEVar beginREnlarge 		= BoolType.newInstance(this);
		RMem MatrixR = new RMem (this, numBlocks, blockDim, SSize, SMaskIDToRemove, betaX, betaY, gammaInv, beginRInit, beginBetaCalc, beginREnlarge, beginRShrink); 			DFEVector<DFEVector<DFEVar>> betaCalcVec = MatrixR.getBetaCalcVec();
		DFEVar XAddr = MatrixR.getXAddr();
		DFEVar YAddr = MatrixR.getYAddr();

		// beta Calculation
		DFEVar betaReadAddr = XAddr;
		DFEVar betaPortAddr = YAddr;
		DFEVar beginBetaSeqRead = beginGammaCCalc | beginGammaVCalc | beginGammaKCalc | stream.offset(beginBookKeeping_S, 1) | beginUpdate;
		betaCalc betaCalcModule = new betaCalc (this, numBlocks, blockDim, SSize, QBufVec, betaCalcVec, beginBetaCalc, betaReadAddr, betaPortAddr, beginBetaSeqRead); 
		betaX <== betaCalcModule.getReadVec();
		betaY <== betaCalcModule.getPortVec();
		DFEVar betaSeq = betaCalcModule.getSeqReadData();
		DFEVar hasBetaCalcFinishedFromBetaCalc = betaCalcModule.hasBetaCalcFinished();		

		// gamma Calculation
		DFEVar GReadAddr 	= IndexNMask;
		DFEVar GWriteAddr 	= IndexNMask;
		DFEVar GWriteEn 		= isGammaVCalculating;
		DFEVar GBeginCalc 	= (beginGammaVCalc | beginGammaCCalc | beginGammaKCalc);
		DFEVar GCalculating 	= isGammaCCalculating | isGammaVCalculating | isGammaKCalculating;
		gammaCalc gammaCalcModule = new gammaCalc (this, WinSize, SSize, QVal, betaSeq, GReadAddr, GWriteAddr, GWriteEn, GBeginCalc, GCalculating);
		DFEVar GammaResult 		= gammaCalcModule.getCalcResult();
		DFEVar GammaResultValid 	= gammaCalcModule.hasFinished();
		DFEVar gamma_c 			= Reductions.streamHold(GammaResult, isGammaCCalculating & GammaResultValid);
		DFEVar gamma_k 			= Reductions.streamHold(GammaResult, isGammaKCalculating & GammaResultValid);
		DFEVar gammaSeq 		= gammaCalcModule.getData();
		DFEVar hasGammaVCalcFinishedFromGammaCalc = (IndexNMask === (NSize-1)) & isGammaVCalculating & GammaResultValid;

		
		////////////////////////// Bookkeeping /////////////////////////
		
		optimization.pushPipeliningFactor(0.9);
		
		DFEVar BKINF = constant.var(Def.BookKeepingType, Def.BookKeepingTH);
		
		// Empty S - Incremental Training - NEED q and hXi
		DFEVar qep = (q>0) ? constant.var(Def.BookKeepingType, Def.ep) : constant.var(Def.BookKeepingType, -Def.ep);
		// bC
		DFEVar bC = KernelMath.abs(hXi+qep);
		DFEVar FlagbC = constant.var(FlagType, 0);
		// bE
		DFEVar bE = (((q>0)&(hXi<-Def.ep))|((q<0)&(hXi>Def.ep))) ? KernelMath.abs(hXi+qep) : BKINF;
		DFEVar FlagbE = (isInc) ? constant.var(FlagType, 1) : constant.var(FlagType, 3);
		// bR
		DFEVar bR = KernelMath.abs(hXi-qep);
		DFEVar FlagbR = (isInc) ? constant.var(FlagType, 2) : constant.var(FlagType, 4);
		
		// Empty S - Decremental Training - bE, bR same as INC, but no bC
		
		
		// Non-Empty S - Incremental Training - NEED q and gamma, gamma_c, theta, beta
		DFEVar BKgamma_c 	= gamma_c.cast(Def.BookKeepingType);
		DFEVar BKthetaSeq 	= thetaSeq.cast(Def.BookKeepingType);
		DFEVar BKbetaSeq 	= betaSeq.cast(Def.BookKeepingType);
		DFEVar BKgammaSeq 	= gammaSeq.cast(Def.BookKeepingType);
		// LC1		
		DFEVar qrc = (q>0) ? BKgamma_c : -BKgamma_c;
		DFEVar LC1_INC = ((qrc>0)&(hXi<-Def.ep)) ? KernelMath.abs((hXi+Def.ep)/BKgamma_c) : (((qrc<0)&(hXi>Def.ep)) ? KernelMath.abs((hXi-Def.ep)/BKgamma_c) : BKINF);
/*
		optimization.pushEnableBitGrowth(true);
		DFEVar toLC1_INC = ((qrc>0)&(hXi<-Def.ep)) ? KernelMath.abs((hXi+Def.ep)/BKgamma_c) : (((qrc<0)&(hXi>Def.ep)) ? KernelMath.abs((hXi-Def.ep)/BKgamma_c) : Def.BookKeepingTH);
		System.out.println("[INFO] Bookkeeping: LC1_INC is calculated using " + toLC1_INC.getType().toString());
		optimization.popEnableBitGrowth();
		DFEVar LC1_INC = (toLC1_INC < Def.BookKeepingTH) ? toLC1_INC.cast(Def.BookKeepingType) : BKINF;
*/		
		// LC2
		DFEVar qC = (q>0) ? constant.var(Def.BookKeepingType, Def.C) : constant.var(Def.BookKeepingType, -Def.C);
		DFEVar LC2_INC = KernelMath.abs(qC-BKthetaSeq);
		// LC_INC
		DFEVar LC_INC = (LC1_INC < LC2_INC) ? LC1_INC : LC2_INC;
		DFEVar FlagLC_INC = (LC1_INC < LC2_INC) ? constant.var(FlagType, 5) : constant.var(FlagType, 6);
		// LiS
		DFEVar qbi 			= (q>0) ? BKbetaSeq : -BKbetaSeq;
		DFEVar LSPos 		= (BKthetaSeq>=0) ? (Def.C - BKthetaSeq) : BKthetaSeq;
		DFEVar LSNeg 		= (BKthetaSeq<=0) ? (Def.C + BKthetaSeq) : BKthetaSeq;
		DFEVar toLS 			= ((qbi>0) ? LSPos : LSNeg) / BKbetaSeq;
		DFEVar LS 			= (qbi===0) ? BKINF : KernelMath.abs(toLS);
/*		
		optimization.pushEnableBitGrowth(true);
		DFEVar toLS 			= KernelMath.abs(((qbi>0) ? LSPos : LSNeg) / BKbetaSeq);
		System.out.println("[INFO] Bookkeeping: LS is calculated using " + toLS.getType().toString());
		optimization.popEnableBitGrowth();
		DFEVar LS 			= (qbi===0) ? BKINF : ((toLS<Def.BookKeepingTH) ? toLS.cast(Def.BookKeepingType) : BKINF);
*/				
		DFEVar FlagLSPosINC 	= (BKthetaSeq>=0) ? constant.var(FlagType, 7) : constant.var(FlagType, 14);
		DFEVar FlagLSNegINC 	= (BKthetaSeq<=0) ? constant.var(FlagType, 7) : constant.var(FlagType, 14);
		DFEVar FlagLSINC 		= (qbi>0) ? FlagLSPosINC : FlagLSNegINC;
		DFEVar FlagLSPosDEC 	= (BKthetaSeq>=0) ? constant.var(FlagType, 11) : constant.var(FlagType, 15);
		DFEVar FlagLSNegDEC 	= (BKthetaSeq<=0) ? constant.var(FlagType, 11) : constant.var(FlagType, 15);
		DFEVar FlagLSDEC 	= (qbi>0) ? FlagLSPosDEC : FlagLSNegDEC;		
		DFEVar FlagLS 		= (isInc) ? FlagLSINC : FlagLSDEC;
		// LiE and LiR shared resources
		DFEVar qri = (q>0) ? BKgammaSeq : -BKgammaSeq;
		DFEVar hXiPlusEpDivGammaSeq = KernelMath.abs((hXi+Def.ep)/BKgammaSeq);
		DFEVar hXiMinusEpDivGammaSeq = KernelMath.abs((hXi-Def.ep)/BKgammaSeq);		
/*
		optimization.pushEnableBitGrowth(true);
		DFEVar tohXiPlusEpDivGammaSeq = KernelMath.abs((hXi+Def.ep)/BKgammaSeq);
		DFEVar tohXiMinusEpDivGammaSeq = KernelMath.abs((hXi-Def.ep)/BKgammaSeq);
		System.out.println("[INFO] Bookkeeping: LE, LR is calculated using " + tohXiPlusEpDivGammaSeq.getType().toString());
		optimization.popEnableBitGrowth();
		DFEVar hXiPlusEpDivGammaSeq = tohXiPlusEpDivGammaSeq < Def.BookKeepingTH ? tohXiPlusEpDivGammaSeq.cast(Def.BookKeepingType) : BKINF;
		DFEVar hXiMinusEpDivGammaSeq = tohXiMinusEpDivGammaSeq < Def.BookKeepingTH ? tohXiMinusEpDivGammaSeq.cast(Def.BookKeepingType) : BKINF;
*/
		// LiE
		DFEVar LE = ((qri>0)&(hXi<=-Def.ep)) ? hXiPlusEpDivGammaSeq : (((qri<0)&(hXi>=Def.ep)) ? hXiMinusEpDivGammaSeq : BKINF);
		DFEVar FlagLE = (isInc) ? constant.var(FlagType, 8) : constant.var(FlagType, 12);
		// LiR
		DFEVar LR = (qri===0) ? BKINF : ((qri>0) ? hXiMinusEpDivGammaSeq : hXiPlusEpDivGammaSeq);
		DFEVar FlagLR = (isInc) ? constant.var(FlagType, 9) : constant.var(FlagType, 13);
		
		// Non-Empty S - Decremental Training - LiS, LiE, LiR same as INC, but LC2 is different, and no LC1
		// LC_DEC
		DFEVar LC_DEC = KernelMath.abs(BKthetaSeq);
		DFEVar FlagLC_DEC = constant.var(FlagType, 10);
		
		// Overall LC
		DFEVar LC = (isInc) ? LC_INC : LC_DEC;
		DFEVar FlagLC = (isInc) ? FlagLC_INC : FlagLC_DEC;
		
		optimization.popPipeliningFactor();
		
		
		// BookKeeping - must offset BookKeepingSel by 1 when iterating over NMask, as Group RAM in StateMachine has latency 1
		DFEVar BKSel 	= isBookKeeping_N ? stream.offset(BookKeepingSel, 1) : BookKeepingSel;
		DFEVar BKVal 	= control.mux(BKSel, bC, bE, bR, LC, LS, LE, LR);
		DFEVar BKFlag 	= control.mux(BKSel, FlagbC, FlagbE, FlagbR, FlagLC, FlagLS, FlagLE, FlagLR);
		DFEVar BKIndex 	= control.mux(BKSel, GroupIndexXc, IndexNMask, IndexNMask, GroupIndexXc, IndexSMask, IndexNMask, IndexNMask);
		
		// A Preliminary solution that handles ties
		DFEVar BKVal_cutoff = (BKVal > BKINF) ? BKINF : BKVal;
		DFEVar minC = Reductions.streamHold(BKVal_cutoff, beginBookKeeping);
		DFEVar FlagC = Reductions.streamHold(BKFlag, beginBookKeeping);
		Reductions.StreamMinInfo BookKeep1 = Reductions.streamMinWithMetadata(BKVal_cutoff, BKFlag, stream.offset(beginBookKeeping, -1), BookKeepingValid);
		Reductions.StreamMinInfo BookKeep2 = Reductions.streamMinWithMetadata(BKVal_cutoff, BKIndex, stream.offset(beginBookKeeping, -1), BookKeepingValid);
		DFEVar isCSmaller = ((minC + Def.eps) < BookKeep1.getMin());
		DFEVar BookKeepingFlag 	= isCSmaller ? FlagC : BookKeep1.getMetaData();
		DFEVar BookKeepingIndex 	= isCSmaller ? GroupIndexXc : BookKeep2.getMetaData();
		DFEVar minL = isCSmaller ? minC : BookKeep1.getMin();
		
/*
		DFEVar BKVal_cutoff = (BKVal > BKINF) ? BKINF : BKVal;
		Reductions.StreamMinInfo BookKeep1 = Reductions.streamMinWithMetadata(BKVal_cutoff, BKFlag, beginBookKeeping, BookKeepingValid);
		Reductions.StreamMinInfo BookKeep2 = Reductions.streamMinWithMetadata(BKVal_cutoff, BKIndex, beginBookKeeping, BookKeepingValid);
		DFEVar BookKeepingFlag 	= BookKeep1.getMetaData();
		DFEVar BookKeepingIndex 	= BookKeep2.getMetaData();
		DFEVar minL	= BookKeep1.getMin();
*/
		
		////////////////////////// Update /////////////////////////
		
		// Update Val
		DFEVar UpdateVal 	= (q>0) ? minL : -minL;
		
		// Update for Empty S
		DFEVar bEmptyS		= UpdateVal;
		DFEVar hXiEmptyS	= UpdateVal;
		
		// Update for Non-Empty S
		DFEVar thetaCNonEmptyS 	= UpdateVal;
		DFEVar bThetaNonEmptyS 	= BKbetaSeq * UpdateVal;
		DFEVar hXcNonEmptyS 	= BKgamma_c * UpdateVal;
		DFEVar hXiNonEmptyS 	= BKgammaSeq * UpdateVal;
		
		// Update b
		OffsetExpr bOffset 		= stream.makeOffsetAutoLoop("bOffset");
		DFEVar bWrData 			= b + (isEmptyS ? bEmptyS : bThetaNonEmptyS).cast(Def.DataYType);
		DFEVar bWrDataOffseted 	= stream.offset(bWrData, -bOffset);
		DFEVar bWrEnOffseted 	= stream.offset(beginUpdate, -bOffset);
		bMem.port(constant.var(dfeUInt(1),0), bWrDataOffseted, bWrEnOffseted, RamWriteMode.WRITE_FIRST);
		
		// Update hXi
		OffsetExpr hXiOffset 			= stream.makeOffsetAutoLoop("hXiOffset");
		DFEVar hXiWrAddrUnOffseted 	= beginUpdate ? GroupIndexXc : GroupIndexNMask;
		DFEVar hXiWrDataUnOffseted 	= (hXi + (isEmptyS ? hXiEmptyS : (beginUpdate ? hXcNonEmptyS : hXiNonEmptyS))).cast(Def.hXiType);
		DFEVar hXiWrEnUnOffseted 	= beginUpdate | isUpdating & NMaskValid;
		DFEVar hXiWrAddrOffseted 		= stream.offset(hXiWrAddrUnOffseted, -hXiOffset);
		DFEVar hXiWrDataOffseted 		= stream.offset(hXiWrDataUnOffseted, -hXiOffset);
		DFEVar hXiWrEnOffseted 		= stream.offset(hXiWrEnUnOffseted, -hXiOffset);
		hXiWrAddr 	<== isRShrinking ? GroupIndexSMask : (isProcessingNewXc ? GroupIndexXc : hXiWrAddrOffseted);
		hXiWrData 	<== hXiWrDataOffseted;
		hXiWrEn 	<== hXiWrEnOffseted;
		
		// Update theta
		OffsetExpr thetaOffset 					= stream.makeOffsetAutoLoop("thetaOffset");
		DFEVar thetaInUnOffseted 				= (BKthetaSeq + (beginUpdate ? thetaCNonEmptyS : bThetaNonEmptyS)).cast(Def.thetaType);
		DFEVar thetaWrBaseAddrUnOffseted 		= beginUpdate ? BaseAddrXc 	: BaseAddrSMask;
		DFEVar thetaWrOffsetAddrUnOffseted 	= beginUpdate ? OffsetAddrXc 	: OffsetAddrSMask;		
		DFEVar thetaImmediateWriteUnOffseted 	= (~isEmptyS) & (beginUpdate | isUpdating & SMaskValid);
		DFEVar thetaInOffseted 				= stream.offset(thetaInUnOffseted, -thetaOffset);
		DFEVar thetaWrBaseAddrOffseted 		= stream.offset(thetaWrBaseAddrUnOffseted, -thetaOffset);
		DFEVar thetaWrOffsetAddrOffseted 		= stream.offset(thetaWrOffsetAddrUnOffseted, -thetaOffset);
		DFEVar thetaImmediateWriteOffseted 	= stream.offset(thetaImmediateWriteUnOffseted, -thetaOffset);
		thetaIn 				<== isProcessingNewXc ? constant.var(Def.thetaType, 0) : thetaInOffseted;
		thetaWrBaseAddr 		<== isThetaKUpdating ? BaseAddrNMask : (isProcessingNewXc ? BaseAddrXc : thetaWrBaseAddrOffseted);
		thetaWrOffsetAddr 	<== isThetaKUpdating ? OffsetAddrNMask : (isProcessingNewXc ? OffsetAddrXc : thetaWrOffsetAddrOffseted);
		thetaImmediateWrite 	<== isProcessingNewXc ? constant.var(dfeBool(), 0) : thetaImmediateWriteOffseted;
		
		
		// REnlarge - triggered by beginGammaCREnlarge or begin automatically after gamma_k calculated
		gammaInv 		<== (1.0 / ((BookKeepingFlag === 5) ? gamma_c : gamma_k)).cast(Def.RType);
		beginREnlarge 	<== beginGammaCREnlarge | stream.offset((isGammaKCalculating & GammaResultValid), -1);
		
		// RShrink
		OffsetExpr SMaskIDToRemoveOffset = stream.makeOffsetAutoLoop("SMaskIDToRemoveOffset");
		SMaskIDToRemove <== stream.offset(BookKeepingIndex, -SMaskIDToRemoveOffset);


		////////////////////////// Feedback /////////////////////////

		// has Xc Join R?
		OffsetExpr hXcOffset = stream.makeOffsetAutoLoop("hXcOffset");
		DFEVar XcJoinROffseted = stream.offset(XcJoinR, -hXcOffset);
		hasFinished <== XcJoinROffseted;

		// has Q Update finished?
		OffsetExpr hasQUpdateFinishedOffset = stream.makeOffsetAutoLoop("hasQUpdateFinishedOffset");
		DFEVar hasQUpdateFinishedFromQMemOffseted = stream.offset(hasQUpdateFinishedFromQMem, -hasQUpdateFinishedOffset);
		hasQUpdateFinished <== hasQUpdateFinishedFromQMemOffseted;
		
		// has BetaCalc finished?
		OffsetExpr hasBetaCalcFinishedOffset = stream.makeOffsetAutoLoop("hasBetaCalcFinishedOffset");
		DFEVar hasBetaCalcFinishedFromBetaCalcOffseted = stream.offset(hasBetaCalcFinishedFromBetaCalc, -hasBetaCalcFinishedOffset);
		hasBetaCalcFinished <== hasBetaCalcFinishedFromBetaCalcOffseted;
		
		// has Gamma Vector calculation finished?
		OffsetExpr hasGammaVCalcFinishedOffset = stream.makeOffsetAutoLoop("hasGammaVCalcFinishedOffset");
		DFEVar hasGammaVCalcFinishedFromGammaCalcOffseted = stream.offset(hasGammaVCalcFinishedFromGammaCalc, -hasGammaVCalcFinishedOffset);
		hasGammaVCalcFinished <== hasGammaVCalcFinishedFromGammaCalcOffseted;

		// BookKeeping result
		OffsetExpr BookKeepingOffset = stream.makeOffsetAutoLoop("BookKeepingOffset");
		BookKeepingFlagOffseted <== stream.offset(BookKeepingFlag, -BookKeepingOffset);
		BookKeepingIndexOffseted <== stream.offset(BookKeepingIndex, -BookKeepingOffset);

		// has Theta[k] update finished?
		hasthetaKUpdateFinished <== thetaKUpdateFinishedFromThetaBlock;
			

		////////////////////////// Debug /////////////////////////
	
		DFEVar Tick = control.count.simpleCounter(32);
		
		// From Input FIFO
//		debug.simPrintf(EnInput, "[%4d]-----[FIFO]---------------data[%d][%d] = (%f,%f) Pushed into FIFO----------\n", Tick, BaseAddrXc, OffsetAddrXc, Xc_IN[0], Yc_IN);
//		debug.simPrintf(XcQueue.valid(), "[%4d]-----[FIFO]---------------data[%d][%d] = (%f,%f) Poped from FIFO----------\n", Tick, BaseAddrXc, OffsetAddrXc, Xc[0], Yc);
		
		// hXc calculation
		debug.simPrintf(EnInput, "\n[%4d]--------[NEW INPUT]-------(Xc[%d][%d],Yc)=(%f,%f)--------------------- b=%.12f ----------------------\n", Tick, BaseAddrXc, OffsetAddrXc, Xc[0], Yc, b);
		//debug.simPrintf(isProcessingNewXc, "[%4d] Addr=%2d, En=%d | Q[0:3]=(%.4f,%.4f,%.4f,%.4f) theta[0:3]=(%.4f,%.4f,%.4f,%.4f) | b = %f | hXc = %f, Valid=%d | XcJoinR=%d, hasFinished=%d\n", Tick, blockAddrGen.getAddr(), isProcessingNewXc, QVector[0], QVector[1], QVector[2], QVector[3], thetaVector[0], thetaVector[1], thetaVector[2], thetaVector[3], b, hXiCalcResult, hXcValid, XcJoinR, hasFinished);
		debug.simPrintf(hasQUpdateFinished, "[%4d] ----------- QUpdate Finished ------------\n", Tick);
		debug.simPrintf(hasFinished, "[%4d] (Xc[%d][%d],Yc) = (%f,%f) joins R. \n", Tick, BaseAddrXc, OffsetAddrXc, Xc[0], Yc);
		
		// BookKeeping
		debug.simPrintf(beginBookKeeping, "[%4d] ----------- Begin BookKeeping ------------\n", Tick);
		debug.simPrintf(BookKeepingValid, "[%4d] N[%d] S[%d] Sel=%d | hXi[%d]=%f, betaSeq=%f, thetaSeq=%f \n                           bC[0]=%f, bE[1]=%f, bR[2]=%f, LC[3]=%f, LS[4]=%f, LE[5]=%f, LR[6]=%f\n", Tick, IndexNMask, IndexSMask, BKSel, hXiRdAddr, hXi, betaSeq, thetaSeq, bC, bE, bR, LC, LS, LE, LR);
		debug.simPrintf(beginUpdate, "[%4d] =======> BookKeeping Result: Flag=%d, Index=%d, minL = %e ------------\n", Tick, BookKeepingFlag, BookKeepingIndex, minL);
		
		// Q Fetch
//		debug.simPrintf(QBufEnWrite, "[%4d] [QBuffer] SMask[%d] - Base=%d, Offset=%d, GroupIndex=%d | Q[%d][%d][%d][%d] => %f | QBuffer[Base][%d] <= %f \n", Tick, IndexSMask, BaseAddrSMask, OffsetAddrSMask, GroupIndexSMask, BaseAddrRow, OffsetAddrRow, BaseAddrCol, OffsetAddrCol, QVal, QBufWriteOffsetAddr, QVal);
		
		// gamma Calc
//		debug.simPrintf(isGammaKCalculating, "[%4d] [GammaKCalc] beginGammaKCalc=%d | QVal([%d][%d], [%d][%d])=%.12f\n", Tick, beginGammaKCalc, BaseAddrRow, OffsetAddrRow, BaseAddrCol, OffsetAddrCol, MatrixQ.getQVal());
		debug.simPrintf(GammaResultValid, "[%4d] [GammaCalc] BG CVK=%d%d%d, CVK=%d%d%d | N=%d, S=%d, NMask[%d], SMask[%d] | Beta=%2.6f, Result=%.12f, Valid=%d | Gamma[C]=%.12f, Gamma[K]=%.12f\n", Tick, beginGammaCCalc, beginGammaVCalc, beginGammaKCalc, isGammaCCalculating, isGammaVCalculating, isGammaKCalculating, NSize, SSize, IndexNMask, IndexSMask, betaSeq, GammaResult, GammaResultValid, gamma_c, gamma_k);

		// hXi update
		debug.simPrintf(hXiWrEn, "[%4d] [hXiUpdate] hXi[%d] <= %.12f, En=%d \n", Tick, hXiWrAddr, hXiWrData, hXiWrEn);
		
		// b update
		debug.simPrintf(bWrEnOffseted, "[%4d] [bUpdate] b <= %.12f \n", Tick, bWrDataOffseted);


		////////////////////////// Simple Kernel /////////////////////////

		io.output("output", Tick, dfeUInt(32));

	}
	
	// RBF Kernel
	private DFEVar RBFKernel(DFEVector<DFEVar>X1, DFEVector<DFEVar>X2) {
		
		DFEVector<DFEVar> temp = (new DFEVectorType<DFEVar>(Def.DataMultType, Def.DataDim)).newInstance(this);
		for (int i=0; i<Def.DataDim; ++i) temp[i] <== (X1[i] - X2[i]).cast(Def.DataMultType);
		DFEVector<DFEVar> summands = (new DFEVectorType<DFEVar>(Def.FixType, Def.DataDim)).newInstance(this);
		for (int i=0; i<Def.DataDim; ++i) summands[i] <== (temp[i] * temp[i]).cast(Def.FixType);
		DFEVar sum = TreeReduce.reduce(new Add<DFEVar>(), summands.getElementsAsList());
		DFEVar result = KernelMath.exp(sum*(-0.5/Def.sigma_sq));
		
		return result.cast(Def.QType);
	}

}
