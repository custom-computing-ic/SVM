import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.SMIO;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.Counter;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.WrapMode;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.KernelMath;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Stream.OffsetExpr;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.memory.Queue;
import com.maxeler.maxcompiler.v2.utils.MathUtils;

import maxpower.ZeroLatencyInput;

class SVMKernel extends Kernel {

	// Divide dataX into several blocks
	private final int numBlocks;
	// 1D Dimension of the block
	private final int blockDim;
	// WinSize
	private final int WinSize;
	// Length of Input Stream
	private final int streamLength;

	SVMKernel(KernelParameters parameters, int numBlocks_IN, int blockDim_IN, int WinSize_IN, int streamLength_IN) {
	
		////////////////////////// Parameters /////////////////////////
		
		super(parameters);
		numBlocks = numBlocks_IN;
		blockDim = blockDim_IN;
		WinSize = WinSize_IN;
		streamLength = streamLength_IN;
		
		DFEVectorType<DFEVar> BlockVecType = new DFEVectorType<DFEVar>(Def.CalcType, numBlocks);
		
		
		////////////////////////// For Debug /////////////////////////
	
		DFEVar Tick = control.count.simpleCounter(32);
		
		
		////////////////////////// State Machine /////////////////////////
		
		SMIO SM = addStateMachine("SVMSM", new SVMStateMachine(this, numBlocks, blockDim, WinSize));
		
		// Control input stream Xc
		DFEVar EnInput = SM.getOutput("EnInput");
		
		// Address of item Xc
		DFEVar BaseAddrXc = SM.getOutput("BaseAddrXc");
		DFEVar OffsetAddrXc = SM.getOutput("OffsetAddrXc");
		
		// Has training Finished
		DFEVar hasFinished = Def.BoolType.newInstance(this);
		SM.connectInput("hasFinished", hasFinished);



		////////////////////////// Input /////////////////////////

		// FIFO Control: Push and Pop at the same cycle
		DFEVar EnPush = EnInput;

		// Xc FIFO
		DFEVector<DFEVar> Xc_IN = ZeroLatencyInput.input("Xc", Def.DataVecType, EnPush, constant.var(dfeUInt(32), streamLength));
		Queue<DFEVector<DFEVar>> XcQueue = mem.queue(Def.DataVecType, 2);
		XcQueue.insert(Xc_IN, EnPush);
		DFEVector<DFEVar> Xc = XcQueue.remove(EnInput);
		DFEVar removeValid = XcQueue.valid();
		
		// Yc FIFO
		DFEVar Yc_IN = ZeroLatencyInput.input("Yc", Def.CalcType, EnPush, constant.var(dfeUInt(32), streamLength));
		Queue<DFEVar> YcQueue = mem.queue(Def.CalcType, 2);
		YcQueue.insert(Yc_IN, EnPush);
		DFEVar Yc = YcQueue.remove(EnInput);
		
		
		debug.simPrintf(EnPush, "[%3d]-----[FIFO]---------------(Xc,Yc) = (%d,%f) Pushed into FIFO----------\n", Tick, Xc_IN[0], Yc_IN);
		debug.simPrintf(removeValid, "[%3d]-----[FIFO]---------------(Xc,Yc) = (%d,%f) Poped from FIFO----------\n", Tick, Xc[0], Yc);

/*		
		// OffsetAddr - [0, blockDim-1]
                Count.Params OffsetAddrParam = control.count.makeParams(MathUtils.bitsToAddress(blockDim))
                							.withInitValue(2)
                							.withMax(blockDim)
                							.withEnable(EnInput)
                							.withWrapMode(WrapMode.COUNT_LT_MAX_THEN_WRAP);
                Counter OffsetAddrCounter = control.count.makeCounter(OffsetAddrParam);
                DFEVar OffsetAddrXc = OffsetAddrCounter.getCount();

		// BaseAddr - [0, numBlocks-1]
                Count.Params BaseAddrParam = control.count.makeParams(MathUtils.bitsToAddress(numBlocks))
                							.withInitValue(0)
                							.withMax(numBlocks)
                							.withEnable(OffsetAddrCounter.getWrap())
                							.withWrapMode(WrapMode.COUNT_LT_MAX_THEN_WRAP);
                Counter BaseAddrCounter = control.count.makeCounter(BaseAddrParam);
                DFEVar BaseAddrXc = BaseAddrCounter.getCount();
*/                
                
//                debug.simPrintf("[%3d] EnInput=%d | BaseAddrXc=%d, OffsetAddrXc=%d \n", Tick, EnInput, BaseAddrXc, OffsetAddrXc);


		////////////////////////// New item Xc /////////////////////////
		
		// Counting Cycles from the Tick of Xc arrival
		//     EnInput: 0, 0, 1, 0, 0, 0, 0, ...,                  0, 0, 0, 0,0,0
		// blockAddr: 0, 0, 0, 1, 2, 3, 4, ..., blockDim-1
		//          valid: 0, 0, 1, 1, 1, 1, 1, ..., 1,
		AddrGenerator blockAddrGen = new AddrGenerator(this, 1, blockDim, EnInput);
		DFEVar blockAddr = blockAddrGen.getAddr();
		DFEVar isProcessingNewXc = blockAddrGen.isValid();

		// dataX: TODO: Add EnWrite Control
		dataXBlock [] DataXBlock = new dataXBlock[numBlocks];
		DFEVector<DFEVector<DFEVar>> dataX = (new DFEVectorType<DFEVector<DFEVar>>(Def.DataVecType, numBlocks)).newInstance(this);
		for (int i=0; i<numBlocks; ++i) {
			DataXBlock[i] = new dataXBlock(this, i, blockDim, Def.DataDim, Xc, BaseAddrXc, OffsetAddrXc, EnInput);
			dataX[i] <== DataXBlock[i].getData();
		}
		
		// dataY
		DFEVar EnDataYIterate = EnInput;
		DFEVar EnDataYWrite = isProcessingNewXc;
		DFEVector<DFEVar> YIn = BlockVecType.newInstance(this);
		for (int i=0; i<numBlocks; ++i) YIn[i] <== Yc;
		dataBlock1D YBlock = new dataBlock1D (this, "dataY", numBlocks, blockDim, YIn, BaseAddrXc, OffsetAddrXc, EnDataYWrite, EnDataYIterate);
		DFEVector<DFEVar> YOut = YBlock.getData();
		
		// Kernel Calc
		DFEVector<DFEVar> KernelVec = BlockVecType.newInstance(this);
		for (int i=0; i<numBlocks; ++i) {
			KernelVec[i] <== Def.RBFKernel(Xc, dataX[i]);
		}
		
		// Matrix Q
		DFEVar EnQIterate = EnInput;
		DFEVar EnQWrite = isProcessingNewXc;
		QMem MatrixQ = new QMem(this, numBlocks, blockDim, KernelVec, BaseAddrXc, OffsetAddrXc, EnQWrite, EnQIterate);
		DFEVector<DFEVar> QVector = MatrixQ.getData();
		
		// theta
		DFEVar EnThetaIterate = EnInput;
		DFEVar EnThetaWrite = constant.var(Def.BoolType, 0);
		DFEVector<DFEVar> thetaIn = BlockVecType.newInstance(this);
		for (int i=0; i<numBlocks; ++i) thetaIn[i] <== constant.var(Def.CalcType, 0);
		dataBlock1D thetaBlock = new dataBlock1D (this, "theta", numBlocks, blockDim, thetaIn, BaseAddrXc, OffsetAddrXc, EnThetaWrite, EnThetaIterate);
		DFEVector<DFEVar> thetaVector = thetaBlock.getData();
		
		// b
		// TODO: store b in ZeroLatency Memory
		DFEVar b = constant.var(Def.CalcType, 1427.320007);
		
		// Calculate hXc
		DFEVar beginhXcCalc = EnInput;
		hCalc hXcCalc = new hCalc(this, blockDim, QVector, thetaVector, b, Yc, beginhXcCalc);
		DFEVar hXc = hXcCalc.getData();
		DFEVar hXcValid = hXcCalc.isValid();
		
		//DFEVar XcJoinR = (KernelMath.abs(hXc)<Def.ep);
		DFEVar XcJoinR = (KernelMath.abs(hXc)<10000) & hXcValid;
		

		// has Incremental Training Finished?
		OffsetExpr hXcOffset = stream.makeOffsetAutoLoop("hXcOffset");
		DFEVar XcJoinROffseted = stream.offset(XcJoinR, -hXcOffset);
//		EnInput <== (Tick<blockDim) ? XcJoinROffseted;
		hasFinished <== XcJoinROffseted;


		
		// For hXc Test
		debug.simPrintf(EnInput, "[%3d]--------NEW INPUT-------(Xc[%d][%d],Yc)=(%d,%f)---------------------------------------------------\n", Tick, BaseAddrXc, OffsetAddrXc, Xc[0], Yc);
		debug.simPrintf(isProcessingNewXc, "[%3d] Addr=%d, En=%d | Q[0:3]=(%.4f,%.4f,%.4f,%.4f) theta[0:3]=(%.4f,%.4f,%.4f,%.4f) | hXc = %f, Valid=%d | XcJoinR=%d, hasFinished=%d\n", Tick, blockAddr, isProcessingNewXc, QVector[0], QVector[1], QVector[2], QVector[3], thetaVector[0], thetaVector[1], thetaVector[2], thetaVector[3], hXc, hXcValid, XcJoinR, hasFinished);

		////////////////////////// Simple Kernel /////////////////////////

		io.output("output", Tick, dfeUInt(32));

	}

}
