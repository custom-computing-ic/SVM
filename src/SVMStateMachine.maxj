import com.maxeler.maxcompiler.v2.kernelcompiler.KernelLib;
import com.maxeler.maxcompiler.v2.statemachine.DFEsmInput;
import com.maxeler.maxcompiler.v2.statemachine.DFEsmOutput;
import com.maxeler.maxcompiler.v2.statemachine.DFEsmStateEnum;
import com.maxeler.maxcompiler.v2.statemachine.DFEsmStateValue;
import com.maxeler.maxcompiler.v2.statemachine.kernel.KernelStateMachine;
import com.maxeler.maxcompiler.v2.statemachine.types.DFEsmValueType;
import com.maxeler.maxcompiler.v2.statemachine.DFEsmDualPortMappedRAM;
import com.maxeler.maxcompiler.v2.statemachine.Latency;
import com.maxeler.maxcompiler.v2.statemachine.stdlib.Mem.DualPortRAMMode;
import com.maxeler.maxcompiler.v2.utils.MathUtils;

import maxpower.SMArrayList;

class SVMStateMachine extends KernelStateMachine {

	////////////////////////// Operating Modes /////////////////////////

        enum Modes {
                IDLE,			// Idle state
                INC,				// Incremental Training
                DEC, 			// Decremental Training
                INCFINISH 		// Incremental Training Finished
        }

	enum subModes {
		SUBIDLE, 			// Idle state of subMode
                QUPDATE,			// Updating Q
                FETCHQ,				// Fetch Q[s1, s2, s3, ...]
                BETACALC,			// Calculating Beta
                GAMMACCALC, 		// Calculating Gamma_c
                GAMMAVCALC, 		// Calculating Gamma Vector
                GAMMAVCALCWAIT, 	// Waiting for Gamma Vector calculation to finish
                BOOKKEEPING_PRE, 	// Starting Point of BookKeeping 
                BOOKKEEPING_C,		// BookKeeping - C
                BOOKKEEPING_S,		// BookKeeping - S
                BOOKKEEPING_N, 		// BookKeeping - N
                UPDATE, 			// Update Coefficients
                UPDATEWAIT,			// Waiting for Update to finish
                INCFLAG,			// Incremental Training : Checking the Flag
                MOVEFETCHQ, 		// Moving Items : Fetching Q
                MOVEBETACALC, 		// Moving Items : Calculating Beta
                GAMMAKCALC, 		// Moving Items : Calculating Gamma[k]
                RENLARGEWAIT, 		// Moving Items : Waiting for REnlarge to Finish
                MOVEN2S,
                MOVES2E,
                MOVES2R,
                
	}
	
	enum maskModes {
		MASKIDLE, 			// Idle state of maskMode
		ITERATE,				// Iterating over Mask
		LASTITEM 			// indicate that current cycle is the last cycle of iteration
	}


        ////////////////////////// Inputs /////////////////////////

	// Finish Trigger
	private final DFEsmInput hasFinished;
	private final DFEsmInput hasQUpdateFinished;
	private final DFEsmInput hasBetaCalcFinished;
	private final DFEsmInput hasGammaVCalcFinished;
	private final DFEsmInput hasthetaKUpdateFinished;
	
	// BookKeeping
	private final DFEsmInput BKFlag;
	private final DFEsmInput BookKeepingIndex;
	

        ////////////////////////// Outputs /////////////////////////

	// For controlled input Xc
	private final DFEsmOutput EnInput;
	
	// INC or DEC
	private final DFEsmOutput isInc;

	// Size
	private final DFEsmOutput SSize;
	private final DFEsmOutput NSize;
	
	// For Q Fetch
	private final DFEsmOutput beginFetchQ;
	private final DFEsmOutput isFetchingQ;
	private final DFEsmOutput QBufWriteOffsetAddr;

	// Base, Offset, Group and Mask Addresses
	private final DFEsmOutput BaseAddrXc;
	private final DFEsmOutput OffsetAddrXc;
	private final DFEsmOutput GroupIndexXc;
	private final DFEsmOutput BaseAddrSMask;
	private final DFEsmOutput OffsetAddrSMask;
	private final DFEsmOutput IndexSMask;
	private final DFEsmOutput GroupIndexSMask;
	private final DFEsmOutput SMaskValid;
	private final DFEsmOutput BaseAddrNMask;
	private final DFEsmOutput OffsetAddrNMask;
	private final DFEsmOutput IndexNMask;
	private final DFEsmOutput GroupIndexNMask;
	private final DFEsmOutput NMaskValid;

	// Bookkeeping
	private final DFEsmOutput beginBookKeeping;
	private final DFEsmOutput BookKeepingSel;
	private final DFEsmOutput BookKeepingValid;
	private final DFEsmOutput beginBetaCalc;
	private final DFEsmOutput beginBookKeeping_S;
	private final DFEsmOutput isBookKeeping_N;
	
	// GammaCalc
	private final DFEsmOutput beginGammaCCalc;
	private final DFEsmOutput isGammaCCalculating;
	private final DFEsmOutput beginGammaVCalc;
	private final DFEsmOutput isGammaVCalculating;

	// Updating	
	private final DFEsmOutput beginUpdate;
	private final DFEsmOutput isUpdating;

	// Moving Items
	private final DFEsmOutput beginMoveFetchQ;
	private final DFEsmOutput isMoveFetchingQ;
	private final DFEsmOutput beginGammaKCalc;
	private final DFEsmOutput isGammaKCalculating;
	private final DFEsmOutput beginRInit;
	private final DFEsmOutput beginGammaCREnlarge;
	private final DFEsmOutput beginRShrink;
	private final DFEsmOutput isRShrinking;
	private final DFEsmOutput beginThetaKUpdate;
	private final DFEsmOutput isThetaKUpdating;
	

        ////////////////////////// State Variables /////////////////////////

        // Counting internal ticks
        private final DFEsmStateValue Tick;
        private final DFEsmStateValue TickCount;
        private final DFEsmStateValue subTick;
        private final DFEsmStateValue BKCount;
        private final DFEsmStateValue GammaCount;
        private final DFEsmStateValue UpdateCount;
        private final DFEsmStateValue FetchQCount;
        
        // Mode and subMode
        private final DFEsmStateEnum<Modes> sMode;
        private final DFEsmStateEnum<subModes> subMode;

        // Current number of samples in the window
        private final DFEsmStateValue CurSize;

        // Xc Address
        private final DFEsmStateValue BaseAddrXcCount;
        private final DFEsmStateValue OffsetAddrXcCount;
        private final DFEsmStateValue GroupIndexXcCount;
        
        // SMask
        private final SMArrayList SMaskBase;
        private final SMArrayList SMaskOffset;
        private final SMArrayList SMaskGroupIndex;
        private final DFEsmStateValue SMaskPos;
        private final DFEsmStateEnum<maskModes> SMaskMode;
        
        // NMask
        private final SMArrayList NMaskBase;
        private final SMArrayList NMaskOffset;
        private final SMArrayList NMaskGroupIndex;
        private final DFEsmStateValue NMaskPos;
        private final DFEsmStateEnum<maskModes> NMaskMode;
        
        // Write Address for QBuffer
        private final DFEsmStateValue QBufWriteOffsetAddrCount;
        
        // Group
	private final DFEsmDualPortMappedRAM Group;


        ////////////////////////// State Variables for Output /////////////////////////

	// beginBetaCalc
	private final DFEsmStateValue toBeginBetaCalc;
        
        
	 ////////////////////////// Parameters /////////////////////////    

	// Dimension Parameters
	private final int numBlocks;
	private final int blockDim;
	private final int WinSize;

	// Scheduling Parameters
	private final int BookKeepingLatency;
	private final int REnlargeLatency;
	private final int RShrinkCycles;


	public SVMStateMachine(KernelLib owner, int numBlocks_IN, int blockDim_IN, int WinSize_IN) {

	 	////////////////////////// Parameters /////////////////////////  

		super(owner);
		
		// Dimension Parameters
		numBlocks 	= numBlocks_IN;
		blockDim 	= blockDim_IN;
		WinSize 		= WinSize_IN;
		
		// Scheduling Parameters
		BookKeepingLatency 	= Def.BookKeepingLatency;
		REnlargeLatency 		= Def.REnlargeLatency;
		RShrinkCycles 		= 3*(blockDim*blockDim + blockDim + Def.RShrinkLatency)+ Def.FetchLatency + 1;


                ////////////////////////// Types /////////////////////////

		DFEsmValueType BoolType 		= dfeBool();
		DFEsmValueType BaseAddrType 	= dfeUInt(MathUtils.bitsToAddress(numBlocks));
		DFEsmValueType OffsetAddrType = dfeUInt(MathUtils.bitsToAddress(blockDim));
		DFEsmValueType PosType 		= dfeUInt(MathUtils.bitsToAddress(WinSize));
		DFEsmValueType CurSizeType 	= dfeUInt(MathUtils.bitsToRepresent(WinSize));
		DFEsmValueType TickType 		= dfeUInt(32);
		DFEsmValueType CountType 	= dfeUInt(16);
		DFEsmValueType SelType 		= dfeUInt(3);
		DFEsmValueType GroupType 	= dfeUInt(3);


                ////////////////////////// Inputs /////////////////////////

		// Finish Trigger
		hasFinished 				= io.input("hasFinished", BoolType);
		hasQUpdateFinished 		= io.input("hasQUpdateFinished", BoolType);
		hasBetaCalcFinished 		= io.input("hasBetaCalcFinished", BoolType);
		hasGammaVCalcFinished 	= io.input("hasGammaVCalcFinished", BoolType);
		hasthetaKUpdateFinished 	= io.input("hasthetaKUpdateFinished", BoolType);
	
		// BookKeeping
		BKFlag 					= io.input("BookKeepingFlag", dfeUInt(4));
		BookKeepingIndex 		= io.input("BookKeepingIndex", PosType);
		

                ////////////////////////// Outputs /////////////////////////

                // Control for input stream Xc
                EnInput 					= io.output("EnInput", BoolType);
                
                // INC or DEC
                isInc 					= io.output("isInc", BoolType);
                
		// Size
                SSize 					= io.output("SSize", CurSizeType);
                NSize 					= io.output("NSize", CurSizeType);
                
		// Control for Q fetch
		beginFetchQ 				= io.output("beginFetchQ", BoolType);
                isFetchingQ 				= io.output("isFetchingQ", BoolType);
                QBufWriteOffsetAddr 		= io.output("QBufWriteOffsetAddr", OffsetAddrType);

		// Base, Offset, Group and Mask Addresses
		BaseAddrXc 				= io.output("BaseAddrXc", BaseAddrType);
		OffsetAddrXc 			= io.output("OffsetAddrXc", OffsetAddrType);
		GroupIndexXc 			= io.output("GroupIndexXc", PosType);
		BaseAddrSMask 			= io.output("BaseAddrSMask", BaseAddrType);
		OffsetAddrSMask 			= io.output("OffsetAddrSMask", OffsetAddrType);
		IndexSMask 				= io.output("IndexSMask", PosType);
		GroupIndexSMask 		= io.output("GroupIndexSMask", PosType);
		SMaskValid 				= io.output("SMaskValid", BoolType);
		BaseAddrNMask 			= io.output("BaseAddrNMask", BaseAddrType);
		OffsetAddrNMask 			= io.output("OffsetAddrNMask", OffsetAddrType);
                IndexNMask 				= io.output("IndexNMask", PosType);
                GroupIndexNMask 		= io.output("GroupIndexNMask", PosType);
                NMaskValid 				= io.output("NMaskValid", BoolType);
		
		// Bookkeeping
		beginBookKeeping 		= io.output("beginBookKeeping", BoolType);
		BookKeepingSel 			= io.output("BookKeepingSel", SelType);
		BookKeepingValid 			= io.output("BookKeepingValid", BoolType);
		beginBetaCalc 			= io.output("beginBetaCalc", BoolType);
		beginBookKeeping_S 		= io.output("beginBookKeeping_S", BoolType);
		isBookKeeping_N 			= io.output("isBookKeeping_N", BoolType);
		
		// GammaCalc
		beginGammaCCalc 		= io.output("beginGammaCCalc", BoolType);
		isGammaCCalculating 		= io.output("isGammaCCalculating", BoolType);
		beginGammaVCalc 		= io.output("beginGammaVCalc", BoolType);
		isGammaVCalculating 		= io.output("isGammaVCalculating", BoolType);
		
		// Updating
		beginUpdate 				= io.output("beginUpdate", BoolType);
		isUpdating 				= io.output("isUpdating", BoolType);
		
		// Moving Items
		beginMoveFetchQ 		= io.output("beginMoveFetchQ", BoolType);
		isMoveFetchingQ 			= io.output("isMoveFetchingQ", BoolType);
		beginGammaKCalc 		= io.output("beginGammaKCalc", BoolType);
		isGammaKCalculating 		= io.output("isGammaKCalculating", BoolType);
		beginRInit 				= io.output("beginRInit", BoolType);
		beginGammaCREnlarge 	= io.output("beginGammaCREnlarge", BoolType); 
		beginRShrink 			= io.output("beginRShrink", BoolType);
		isRShrinking 				= io.output("isRShrinking", BoolType);
		beginThetaKUpdate 		= io.output("beginThetaKUpdate", BoolType);
		isThetaKUpdating 			= io.output("isThetaKUpdating", BoolType);
		

                ////////////////////////// Init State Variables /////////////////////////
                
		// Tick
		Tick 				= state.value(TickType, 0);
		TickCount 			= state.value(TickType, 0);
		subTick 				= state.value(TickType, 0);
		BKCount 			= state.value(CountType, 0);
		GammaCount 		= state.value(CountType, 0);
		UpdateCount 		= state.value(CountType, 0);
		FetchQCount 			= state.value(CountType, 0);
		
		// Mode and subMode
		sMode 				= state.enumerated(Modes.class, Modes.IDLE);
		subMode 			= state.enumerated(subModes.class, subModes.SUBIDLE);
		
		// CurSize
		CurSize 				= state.value(CurSizeType, 2);
		
		// Xc Address
		BaseAddrXcCount 	= state.value(BaseAddrType, 0);
		OffsetAddrXcCount 	= state.value(OffsetAddrType, 2);
		GroupIndexXcCount	= state.value(PosType, 2);
		
		// SMask
		SMaskBase 			= new SMArrayList(this, BaseAddrType, WinSize);
		SMaskOffset 			= new SMArrayList(this, OffsetAddrType, WinSize);
		SMaskGroupIndex 	= new SMArrayList(this, PosType, WinSize);
		SMaskPos 			= state.value(PosType, 0);
		SMaskMode 			= state.enumerated(maskModes.class, maskModes.MASKIDLE);

		// NMask - the first two elements belong to E
		NMaskBase 			= new SMArrayList(this, BaseAddrType, WinSize, 2, 0, 0);
		NMaskOffset 			= new SMArrayList(this, OffsetAddrType, WinSize, 2, 0, 1);
		NMaskGroupIndex 	= new SMArrayList(this, PosType, WinSize, 2, 0, 1);
		NMaskPos 			= state.value(PosType, 0);
		NMaskMode 			= state.enumerated(maskModes.class, maskModes.MASKIDLE);

		// Write Address for QBuffer
		QBufWriteOffsetAddrCount 	= state.value(OffsetAddrType, 0);
		
		// Group: 0=N, 1=S, 2=E, 3=R, 4=C
		Group = mem.ramMappedDualPort("Group", GroupType, WinSize, DualPortRAMMode.READ_ONLY, DualPortRAMMode.WRITE_ONLY, Latency.ONE_CYCLE);
		
		
        	////////////////////////// Init State Variables for Output /////////////////////////
        		
		toBeginBetaCalc 		= state.value(BoolType, false);

        }
        
	@Override
	protected void nextState() {
	
		////////////////////////// Debug /////////////////////////
		
		Tick.next <== Tick + 1;
//		IF (subTick===0) debug.simPrintf("[%4d] sMode = %4s | [%4d] subMode = %16s | SSize=%d, NSize=%d | SMaskPos = %d, NMaskPos = %d \n", Tick, sMode, subTick, subMode, SMaskBase.size(), NMaskBase.size(), SMaskPos, NMaskPos);
//		IF (subMode === subModes.BOOKKEEPING_PRE | subMode === subModes.BOOKKEEPING_C | subMode === subModes.BOOKKEEPING_N | subMode === subModes.BOOKKEEPING_S) debug.simPrintf("[%4d] sMode = %4s | [%4d] subMode = %16s | SSize=%d, NSize=%d | SMaskPos = %d, NMaskPos = %d | Group[prev]=%d \n", Tick, sMode, subTick, subMode, SMaskBase.size(), NMaskBase.size(), SMaskPos, NMaskPos, Group.dataOutA);
		
		////////////////////////// Default /////////////////////////

		Group.writeEnableB 		<== false;
		toBeginBetaCalc.next 		<== false;


		////////////////////////// sMode /////////////////////////
		
		SWITCH(sMode) {
			// IDLE
			CASE(Modes.IDLE) {
				IF (CurSize<WinSize) {sMode.next <== Modes.INC;}
				ELSE {sMode.next <== Modes.DEC;} // TODO: Control Logic for Decremental Training
				TickCount.next <== 0;
				subTick.next <== 0;
                        }
                        // Incremental Training
                        CASE(Modes.INC) {
				TickCount.next <== TickCount + 1;
                        	IF (hasFinished === true) {
                        		// Xc joins R and terminate
                        		groupWrite(GroupIndexXcCount, 'R');
					NMaskBase.add(BaseAddrXcCount);
					NMaskOffset.add(OffsetAddrXcCount);
					NMaskGroupIndex.add(GroupIndexXcCount);
                        		sMode.next <== Modes.INCFINISH;
                        	}
                        }
                        // Decremental Training
			CASE(Modes.DEC) {
				TickCount.next <== TickCount + 1;
                        	IF (hasFinished === true) {
                        		sMode.next <== Modes.IDLE;
                        		CurSize.next <== CurSize - 1;
                        	}
                        }
                        // Incremental Training Finished
                        CASE(Modes.INCFINISH) {
                        	// Incremental Training has finished, return to IDLE
				// Update CurSize, and Xc Addr
                        	sMode.next <== Modes.IDLE;
                       		subMode.next <== subModes.SUBIDLE;
                    		CurSize.next <== CurSize + 1;
                   		IF (OffsetAddrXcCount === (blockDim-1)) {
                     			OffsetAddrXcCount.next <== 0;
                        		IF (BaseAddrXcCount === (numBlocks-1)) {BaseAddrXcCount.next <== 0;}
                        		ELSE {BaseAddrXcCount.next <== BaseAddrXcCount + 1;}
                        	}
                        	ELSE {OffsetAddrXcCount.next <== OffsetAddrXcCount + 1;}
                        	IF (GroupIndexXcCount === (WinSize-1)) {GroupIndexXcCount.next <== 0;}
                        	ELSE {GroupIndexXcCount.next <== GroupIndexXcCount + 1;}
                        }
                        
                } // end of SWITCH(sMode)
                

		////////////////////////// subMode /////////////////////////
                
                SWITCH(subMode) {
                	// SUBIDLE
                	CASE(subModes.SUBIDLE) {
                		IF (sMode === Modes.INC) {subMode.next <== subModes.QUPDATE;}
                		ELSE {subMode.next <== subModes.SUBIDLE;} // TODO: Control for decremental training
                	}
			// QUPDATE - INC only
			CASE(subModes.QUPDATE) {
				IF (hasQUpdateFinished === true) subMode.next <== subModes.BOOKKEEPING_PRE;
			}
                        // BOOKKEEPING_PRE
                        CASE(subModes.BOOKKEEPING_PRE) {
				IF (~SMaskBase.isEmpty()) {
                        		// Non-Empty S - goto FetchQ
                        		subMode.next <== subModes.FETCHQ;
                        		FetchQCount.next <== 0;
                        		SMaskPos.next <== 0;
                        		SMaskMode.next <== maskModes.ITERATE;
                        		QBufWriteOffsetAddrCount.next <== 1;
					NMaskPos.next <== 0;
                        	}
                        	ELSE {
                        		// EmptyS - goto bookkeeping_c
                        		gotoBookKeeping_C();
                        	}
                        }
                        // FETCHQ
                        CASE(subModes.FETCHQ) {
				FetchQCount.next <== FetchQCount + 1;
                        	// Write Address for Q Buffer
                        	IF (QBufWriteOffsetAddrCount === (blockDim-1)) QBufWriteOffsetAddrCount.next <== 0;
                        	ELSE QBufWriteOffsetAddrCount.next <== QBufWriteOffsetAddrCount + 1;
                        	// SMask iteration + padding zero
                        	IF (FetchQCount === WinSize-2)  {
                        		subMode.next <== subModes.BETACALC;
                        		toBeginBetaCalc.next <== true;
                        	}
                        }
                        // BETACALC
                        CASE(subModes.BETACALC) {
                        	IF (hasBetaCalcFinished === true) {
                        		subMode.next <== subModes.GAMMACCALC;
                        		GammaCount.next <== 0;
                        	}
                        }
                        // GAMMACCALC
                        CASE(subModes.GAMMACCALC) {
                        	GammaCount.next <== GammaCount + 1;
				IF (GammaCount === 0) {SMaskMode.next <== maskModes.ITERATE; SMaskPos.next <== 0;}
                        	IF (GammaCount === SMaskBase.size().cast(dfeUInt(16))) {
                        		IF (~NMaskBase.isEmpty()) {
                        			subMode.next <== subModes.GAMMAVCALC;
						SMaskPos.next <== 0;
						NMaskPos.next <== 0;
						GammaCount.next <== 0;               						
                        		}
                        		ELSE gotoBookKeeping_C();
                        	}
                        }
                        // GAMMAVCALC
                        CASE(subModes.GAMMAVCALC) {
                        	GammaCount.next <== GammaCount + 1;
                        	IF (GammaCount === 0) {SMaskMode.next <== maskModes.ITERATE; SMaskPos.next <== 0;}
                        	IF (GammaCount === SMaskBase.size().cast(dfeUInt(16))) {
                        		IF ((NMaskPos.cast(dfeUInt(MathUtils.bitsToRepresent(WinSize))) === NMaskBase.size()-1)) {
                        			subMode.next <== subModes.GAMMAVCALCWAIT;
                        		}
                        		ELSE {NMaskPos.next <== NMaskPos+1;}
                        		GammaCount.next <== 0; 
                        	}
                        }
			// GAMMAVCALCWAIT
                        CASE(subModes.GAMMAVCALCWAIT) {
                        	IF (hasGammaVCalcFinished === true) gotoBookKeeping_C();
                        }
                        // BOOKKEEPING_C
			CASE(subModes.BOOKKEEPING_C) {
				IF (~NMaskBase.isEmpty()) gotoBookKeeping_N();
				ELSE {
					IF (~SMaskBase.isEmpty()) gotoBookKeeping_S();
					ELSE gotoUpdate();
				}
			}
			// BOOKKEEPING_N
			CASE(subModes.BOOKKEEPING_N) {
				BKCount.next <== BKCount + 1;
				Group.addressA <== NMaskGroupIndex.get(NMaskPos);
				IF (NMaskMode === maskModes.MASKIDLE) {
					IF (~SMaskBase.isEmpty()) gotoBookKeeping_S();
					ELSE gotoUpdate();
				}
			}
			// BOOKKEEPING_S
			CASE(subModes.BOOKKEEPING_S) {
				BKCount.next <== BKCount + 1;
				Group.addressA <== SMaskGroupIndex.get(SMaskPos);
				IF (SMaskMode === maskModes.MASKIDLE) gotoUpdate();
			}			
			// UPDATE
			CASE(subModes.UPDATE) {
				UpdateCount.next <== UpdateCount + 1;
				IF (UpdateCount === 0) {
					SMaskMode.next <== maskModes.ITERATE;
					NMaskMode.next <== maskModes.ITERATE;							
				}
				ELSE {
					IF ((SMaskMode === maskModes.MASKIDLE) & (NMaskMode === maskModes.MASKIDLE)) {
						subMode.next <== subModes.UPDATEWAIT;
						UpdateCount.next <== 0;
					}
				}
			}
			// UPDATEWAIT
			CASE(subModes.UPDATEWAIT) {
				UpdateCount.next <== UpdateCount + 1;
				IF (UpdateCount === BookKeepingLatency) {subMode.next <== subModes.INCFLAG; subTick.next <== 0;}
			}
						// Incremental Training : Checking the flag
						CASE(subModes.INCFLAG) {
							subTick.next <== subTick + 1;
							SWITCH(BKFlag) {
								CASE(0) {
									// Xc Joins R and terminate
									groupWrite(GroupIndexXcCount, 'R');
									NMaskBase.add(BaseAddrXcCount);
									NMaskOffset.add(OffsetAddrXcCount);
									NMaskGroupIndex.add(GroupIndexXcCount);
									subMode.next <== subModes.SUBIDLE;
									sMode.next <== Modes.INCFINISH;
									
									debug.simPrintf("[%4d] =======> Item[%d] joins R, becomes NMask[%d] (Base=%d, Offset=%d, GroupIndex=%d).\n", Tick, GroupIndexXcCount, NMaskBase.size(), BaseAddrXcCount, OffsetAddrXcCount, GroupIndexXcCount);
								}
								CASE(1) {
									// N[index] moves from E to S
									IF (SMaskBase.isEmpty()) {
										// beginRInit and return to BOOKKEEPING after Finish
										IF (subTick === blockDim*2) {subMode.next <== subModes.MOVEN2S;}
									}
									ELSE {
										NMaskPos.next <== BookKeepingIndex;  // should keep that value through moving process
										gotoMoveFetchQ();
									}
								}
								CASE(2) { // handled the same way as case 1
									// S[index] moves from R to S
									IF (SMaskBase.isEmpty()) {
										// beginRInit and return to BOOKKEEPING after Finish
										IF (subTick === blockDim*2) {subMode.next <== subModes.MOVEN2S;}
									}
									ELSE {
										NMaskPos.next <== BookKeepingIndex;  // should keep that value through moving process
										gotoMoveFetchQ();
									}
								}
//								CASE(3) {}
//								CASE(4) {}
								CASE(5) {
									// Xc joins S and terminate
									IF (subTick === blockDim*blockDim + REnlargeLatency) {
										groupWrite(GroupIndexXcCount, 'S');
										SMaskBase.add(BaseAddrXcCount);
										SMaskOffset.add(OffsetAddrXcCount);
										SMaskGroupIndex.add(GroupIndexXcCount);
										subMode.next <== subModes.SUBIDLE;
										sMode.next <== Modes.INCFINISH;
										
										debug.simPrintf("[%4d] =======> Item[%d] joins S, becomes SMask[%d] (Base=%d, Offset=%d, GroupIndex=%d).\n", Tick, GroupIndexXcCount, SMaskBase.size(), BaseAddrXcCount, OffsetAddrXcCount, GroupIndexXcCount);
                        						}
								}
								CASE(6) {
									// Xc joins E and terminate
									groupWrite(GroupIndexXcCount, 'E');
									NMaskBase.add(BaseAddrXcCount);
									NMaskOffset.add(OffsetAddrXcCount);
									NMaskGroupIndex.add(GroupIndexXcCount);
									sMode.next <== Modes.INCFINISH;
									subMode.next <== subModes.SUBIDLE;
									
									debug.simPrintf("[%4d] =======> Item[%d] joins E, becomes NMask[%d] (Base=%d, Offset=%d, GroupIndex=%d).\n", Tick, GroupIndexXcCount, NMaskBase.size(), BaseAddrXcCount, OffsetAddrXcCount, GroupIndexXcCount);
								}
								CASE(7) {
									// N[index] moves from S to E
									// begin RShrink and hXi update when subTick===1
									SMaskPos.next <== BookKeepingIndex;
									IF (subTick === RShrinkCycles) {
										subMode.next <== subModes.MOVES2E;
									}
								}
								
							
								CASE(8) {
									// N[index] moves from E to S
									NMaskPos.next <== BookKeepingIndex; // should keep that value through moving process
									IF (hasthetaKUpdateFinished === true) gotoMoveFetchQ();
									
								}
								CASE(9) {
									// N[index] moves from R to S
									NMaskPos.next <== BookKeepingIndex; // should keep that value through moving process
									IF (hasthetaKUpdateFinished === true) gotoMoveFetchQ();
								}
//								CASE(10) {}
//								CASE(11) {}
//								CASE(12) {}
//								CASE(13) {}
								CASE(14) {
									// N[index] moves from S to R						
									// begin RShrink and hXi update when subTick===1
									SMaskPos.next <== BookKeepingIndex;
									IF (subTick === RShrinkCycles) {
										subMode.next <== subModes.MOVES2R;
									}
								}
//								CASE(15) {}
								
							} // end of switch (BKFLAG)
						}
			// MOVEFETCHQ
			CASE(subModes.MOVEFETCHQ) {
				FetchQCount.next <== FetchQCount + 1;
                        	// Write Address for Q Buffer
                        	IF (QBufWriteOffsetAddrCount === (blockDim-1)) {QBufWriteOffsetAddrCount.next <== 0;}
                        	ELSE {QBufWriteOffsetAddrCount.next <== QBufWriteOffsetAddrCount + 1;}
                        	// SMask iteration + padding zero
                        	IF (FetchQCount === WinSize-2)  {
                        		subMode.next <== subModes.MOVEBETACALC; 
                        		toBeginBetaCalc.next <== true;
                        	}						
			}
						// Move item from N to S : Beta Calc
						CASE(subModes.MOVEBETACALC) {
                        				IF (hasBetaCalcFinished === true) {
                        					subMode.next <== subModes.GAMMAKCALC;
                        					GammaCount.next <== 0;
                        				}						
						}
                        			// Calculating gamma_k
                        			CASE(subModes.GAMMAKCALC) {
                        				GammaCount.next <== GammaCount + 1;
							IF (GammaCount === 0) {SMaskMode.next <== maskModes.ITERATE; SMaskPos.next <== 0;}
                        				IF (GammaCount === SMaskBase.size().cast(dfeUInt(16))) {
                        					subTick.next <== 0;
                        					subMode.next <== subModes.RENLARGEWAIT;
                        				}
                        			}
                        			// Waiting for REnlarge to Finish
                        			CASE(subModes.RENLARGEWAIT) {
                        				subTick.next <== subTick + 1;
                        				IF (subTick === blockDim*blockDim + REnlargeLatency) {
                        					subTick.next <== 0;
                        					subMode.next <== subModes.MOVEN2S;
                        				}
                        			}
                        			// Move Item from N to S
                        			CASE(subModes.MOVEN2S) {
							Group.addressB <== NMaskGroupIndex.get(BookKeepingIndex);
							Group.dataInB <== 1;
							Group.writeEnableB <== true;
							SMaskBase.add(NMaskBase.get(BookKeepingIndex));
							SMaskOffset.add(NMaskOffset.get(BookKeepingIndex));
							SMaskGroupIndex.add(NMaskGroupIndex.get(BookKeepingIndex));
							NMaskBase.remove(BookKeepingIndex);
							NMaskOffset.remove(BookKeepingIndex);
							NMaskGroupIndex.remove(BookKeepingIndex);
							// Continue BookKeeping
                        				subMode.next <== subModes.BOOKKEEPING_PRE;
                        				
                        				debug.simPrintf("[%4d] =======> Item[%d] moves from N to S.\n", Tick, NMaskGroupIndex.get(BookKeepingIndex));
                        			}
                        			// Move Item from S to E
                        			CASE(subModes.MOVES2E) {
                        				Group.addressB <== SMaskGroupIndex.get(BookKeepingIndex);
                        				Group.dataInB <== 2;
                        				Group.writeEnableB <== true;
  							NMaskBase.add(SMaskBase.get(BookKeepingIndex));
							NMaskOffset.add(SMaskOffset.get(BookKeepingIndex));
							NMaskGroupIndex.add(SMaskGroupIndex.get(BookKeepingIndex));
							SMaskBase.remove(BookKeepingIndex);
							SMaskOffset.remove(BookKeepingIndex);
							SMaskGroupIndex.remove(BookKeepingIndex);
							// Continue BookKeeping
                        				subMode.next <== subModes.BOOKKEEPING_PRE;
                        				
                        				debug.simPrintf("[%4d] =======> Item[%d] moves from S to E.\n", Tick, SMaskGroupIndex.get(BookKeepingIndex));
                        			}
                          			// Move Item from S to R
                        			CASE(subModes.MOVES2R) {
                        				Group.addressB <== SMaskGroupIndex.get(BookKeepingIndex);
                        				Group.dataInB <== 3;
                        				Group.writeEnableB <== true;
  							NMaskBase.add(SMaskBase.get(BookKeepingIndex));
							NMaskOffset.add(SMaskOffset.get(BookKeepingIndex));
							NMaskGroupIndex.add(SMaskGroupIndex.get(BookKeepingIndex));
							SMaskBase.remove(BookKeepingIndex);
							SMaskOffset.remove(BookKeepingIndex);
							SMaskGroupIndex.remove(BookKeepingIndex);
							// Continue BookKeeping
                        				subMode.next <== subModes.BOOKKEEPING_PRE;	
                        				
                        				debug.simPrintf("[%4d] =======> Item[%d] moves from S to R.\n", Tick, SMaskGroupIndex.get(BookKeepingIndex));
						}


		}


		////////////////////////// Mask /////////////////////////
		
		// SMask
		SWITCH(SMaskMode) {
			CASE (maskModes.ITERATE) {
				IF (SMaskBase.size() <= 1) {SMaskMode.next <== maskModes.MASKIDLE; SMaskPos.next <== 0;}
				ELSE {
					SMaskPos.next <== SMaskPos + 1;
					IF (SMaskPos.cast(dfeUInt(MathUtils.bitsToRepresent(WinSize)))+2 >= SMaskBase.size()) {SMaskMode.next <== maskModes.LASTITEM;}
				}
			}
			CASE (maskModes.LASTITEM) {
				SMaskMode.next <== maskModes.MASKIDLE; 
				SMaskPos.next <== 0;				
			}
		}
		
		// NMask
		SWITCH(NMaskMode) {
			CASE (maskModes.ITERATE) {
				IF (NMaskBase.size() <= 1) {NMaskMode.next <== maskModes.MASKIDLE; NMaskPos.next <== 0;}
				ELSE {
					NMaskPos.next <== NMaskPos + 1;
					IF (NMaskPos.cast(dfeUInt(MathUtils.bitsToRepresent(WinSize)))+2 >= NMaskBase.size()) {NMaskMode.next <== maskModes.LASTITEM;}
				}
			}
			CASE (maskModes.LASTITEM) {
				NMaskMode.next <== maskModes.MASKIDLE; 
				NMaskPos.next <== 0;				
			}
		}	
                
        }

        @Override
        protected void outputFunction() {
		
        	// Control Signal for Input Stream Xc
        	EnInput <== (sMode === Modes.INC) & (TickCount === 0);
        	
		// INC or DEC
		isInc <== (sMode === Modes.INC);
        	
        	// Size
        	SSize <== SMaskBase.size();
        	NSize <== NMaskBase.size();
        	
  		// FetchQ
		beginFetchQ 			<== (subMode === subModes.FETCHQ) & (FetchQCount === 0);
		isFetchingQ 			<== (subMode === subModes.FETCHQ);
		beginMoveFetchQ 	<== (subMode === subModes.MOVEFETCHQ) & (FetchQCount === 0);
		isMoveFetchingQ 		<== (subMode === subModes.MOVEFETCHQ);
		QBufWriteOffsetAddr 	<== QBufWriteOffsetAddrCount;
        	
        	// Base and Offset Addresses of Xc, SMask, NMask. Index of SMask and NMask
		BaseAddrXc 			<== BaseAddrXcCount;
		OffsetAddrXc 		<== OffsetAddrXcCount;
		GroupIndexXc 		<== GroupIndexXcCount;
		BaseAddrSMask 		<== SMaskBase.get(SMaskPos);
		OffsetAddrSMask 		<== SMaskOffset.get(SMaskPos);
		IndexSMask 			<== SMaskPos;
		GroupIndexSMask		<== SMaskGroupIndex.get(SMaskPos);
		SMaskValid 			<== (SMaskMode !== maskModes.MASKIDLE);
		BaseAddrNMask 		<== NMaskBase.get(NMaskPos);
		OffsetAddrNMask 		<== NMaskOffset.get(NMaskPos);
		IndexNMask 			<== NMaskPos;
		GroupIndexNMask		<== NMaskGroupIndex.get(NMaskPos);
		NMaskValid 			<== (NMaskMode !== maskModes.MASKIDLE);
		
		
		////////////////////////// BookKeeping /////////////////////////
		
		// beginBookKeeping
		beginBookKeeping 	<== (subMode === subModes.BOOKKEEPING_C);
		beginBookKeeping_S 	<== (subMode === subModes.BOOKKEEPING_S) & (BKCount === 0);
		isBookKeeping_N 		<== (subMode === subModes.BOOKKEEPING_N);
		
		// BookKeepingSel
		IF (sMode === Modes.INC) {
			SWITCH (subMode) {
				CASE (subModes.BOOKKEEPING_C) {
					IF (SMaskBase.isEmpty()) BookKeepingSel <== 0;  // bC
					ELSE BookKeepingSel <== 3;  // LC
				}
				CASE (subModes.BOOKKEEPING_N) {
					IF (SMaskBase.isEmpty()) {
						SWITCH (Group.dataOutA) {
							CASE(2) {BookKeepingSel <== 1;} // bE
							CASE(3) {BookKeepingSel <== 2;} // bR
							OTHERWISE {BookKeepingSel <== 0;}
						}
					}
					ELSE {
						SWITCH (Group.dataOutA) {
							CASE(2) {BookKeepingSel <== 5;} // bE
							CASE(3) {BookKeepingSel <== 6;} // bR
							OTHERWISE {BookKeepingSel <== 0;}
						}			
					}
//					debug.simPrintf("[%4d] [%s] NMask[%d] = Item[%d], Group.dataOutA[prevNMask] = %d \n", Tick, subMode, NMaskPos, NMaskGroupIndex.get(NMaskPos), Group.dataOutA);		
				}
				CASE (subModes.BOOKKEEPING_S) {
					BookKeepingSel <== 4; // LS
//					debug.simPrintf("[%4d] [%s] Generating BookKeeping Selection Signal: Group.dataOutA=%d \n", Tick, subMode, Group.dataOutA);
				}
				OTHERWISE {BookKeepingSel <== 0;}
			}
			
		}
		ELSE {
			// TODO: DEC
			BookKeepingSel <== 0;
		}
		
		// BookKeepingValid
		SWITCH (subMode) {
			CASE (subModes.BOOKKEEPING_C) {BookKeepingValid <== 1;}
			CASE (subModes.BOOKKEEPING_N) {BookKeepingValid <== (NMaskMode !== maskModes.MASKIDLE);}
			CASE (subModes.BOOKKEEPING_S) {BookKeepingValid <== (SMaskMode !== maskModes.MASKIDLE);}
			OTHERWISE {BookKeepingValid <== 0;}
		}


		// BetaCalc
		beginBetaCalc 			<== toBeginBetaCalc;		
		
		// GammaCalc
		beginGammaCCalc 		<== (subMode === subModes.GAMMACCALC) & (GammaCount === 0);
		isGammaCCalculating 		<== (subMode === subModes.GAMMACCALC);
		beginGammaVCalc 		<== (subMode === subModes.GAMMAVCALC) & (GammaCount === 0);
		isGammaVCalculating 		<== (subMode === subModes.GAMMAVCALC);
		beginGammaKCalc 		<== (subMode === subModes.GAMMAKCALC) & (GammaCount === 0);
		isGammaKCalculating 		<== (subMode === subModes.GAMMAKCALC);
		
		// Update
		beginUpdate 				<== (subMode === subModes.UPDATE) & (UpdateCount === 0);
		isUpdating 				<== (subMode === subModes.UPDATE);
		
		// Moving Items
		beginGammaCREnlarge 	<== (subMode === subModes.INCFLAG) & (BKFlag === 5) & (subTick === 0);
		beginRInit 				<== (subMode === subModes.INCFLAG) & ((BKFlag === 1) | (BKFlag === 2)) & SMaskBase.isEmpty() & (subTick === 0);
		beginRShrink 			<== (subMode === subModes.INCFLAG) & ((BKFlag === 7) | (BKFlag === 14)) & (subTick === 1);
		isRShrinking 				<== (subMode === subModes.INCFLAG) & ((BKFlag === 7) | (BKFlag === 14)) & (subTick > 0);
		beginThetaKUpdate 		<== (subMode === subModes.INCFLAG) & ((BKFlag === 8) | (BKFlag === 9)) & (subTick === 1);
		isThetaKUpdating 			<== (subMode === subModes.INCFLAG) & ((BKFlag === 8) | (BKFlag === 9)) & (subTick > 0);
		
        }
        
	////////////////////////// Utility Functions /////////////////////////
	
	// goto BookKeeping_C
	private void gotoBookKeeping_C() {
		subMode.next 	<== subModes.BOOKKEEPING_C;
	}

	// goto BookKeeping_S
	private void gotoBookKeeping_S() {
		subMode.next 	<== subModes.BOOKKEEPING_S;
		SMaskPos.next 	<== 0;
		SMaskMode.next 	<== maskModes.ITERATE;
		Group.addressA 	<== SMaskGroupIndex.get(0);
		BKCount.next 	<== 0;
	}
	
	// goto BookKeeping_N
	private void gotoBookKeeping_N() {
		subMode.next 	<== subModes.BOOKKEEPING_N;
		NMaskPos.next 	<== 0;
		NMaskMode.next 	<== maskModes.ITERATE;
		Group.addressA 	<== NMaskGroupIndex.get(0);
		BKCount.next 	<== 0;
	}
	
	// goto Update
	private void gotoUpdate() {
		subMode.next 	<== subModes.UPDATE;
		UpdateCount.next <== 0;
	}
	
	// goto MoveFetchQ
	private void gotoMoveFetchQ() {
		subMode.next <== subModes.MOVEFETCHQ;
		SMaskPos.next <== 0;
		SMaskMode.next <== maskModes.ITERATE;
		QBufWriteOffsetAddrCount.next <== 1;
		FetchQCount.next <== 0;	
	}
	
	// write to group array
	private void groupWrite(DFEsmStateValue index, char data) {
		int wrData;
		switch (data) {
			case 'S': wrData = 1; break;
			case 'E': wrData = 2; break;
			case 'R': wrData = 3; break;
			case 'C': wrData = 4; break;
			default: wrData = 0; break;
		}
		Group.addressB <== index;
		Group.dataInB <== wrData;
		Group.writeEnableB <== true;
	}
        
}

