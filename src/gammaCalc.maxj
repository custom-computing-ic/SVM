import com.maxeler.maxcompiler.v2.kernelcompiler.KernelLib;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.Counter;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.WrapMode;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.memory.Memory;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.Reductions;

import maxpower.FloatingPointAccumulator;

/**
 * This class calculates gamma
 *
 * @author Patrick Shao
 *
 * @param <blockDim> 1D Dimension of the block - Block Size = blockDim^2
 * @param <Q> Incoming Q values
 * 		- If calculating gamma_k, Q should be Q[k][k] on the first cycle
 * 		- If calculating ith element for gamma vector, Q should be Q[NMask[i]][Xc] on the first cycle 
 * @param <beta> beta Vector
 * @param <isDataValid> is incoming data valid, true during calculation
 * @param <beginGammaVCalc> Trigger of gamma vector calculation, also resets accumulator
 * @param <beginGammaCCalc> Trigger of gamma_c calculation, also resets accumulator
 * 
 */



class gammaCalc extends KernelLib {

	private DFEVar Result;
	private DFEVar Data;
	private DFEVar hasFinish;
	
	public DFEVar getCalcResult() 			{return Result;}
	public DFEVar getData() 		{return Data;}
	public DFEVar hasFinished() 		{return hasFinish;}
	
	gammaCalc ( 	KernelLib owner,
				int WinSize, 
				DFEVar SSize, 
				DFEVar Q, 
				DFEVar beta, 
				DFEVar GammaReadAddr, 
				DFEVar GammaWriteAddr,
				DFEVar GammaWriteEn,
				DFEVar beginCalc,
				DFEVar isCalculating) 
	{
	
		super(owner);
		
		/////////////////////// Control ///////////////////////
		
		// Latest SSize is read only at the beginning of Gamma calculation
		DFEVar SSizeForGammaCalc = Reductions.streamHold(SSize, beginCalc).cast(dfeUInt(16));
		DFEVar Max = SSizeForGammaCalc + 1;
                Count.Params GammaCounterParam = control.count.makeParams(16)
                							.withInitValue(0)
                							.withEnable(isCalculating)
                							.withMax(Max)
                							.withWrapMode(WrapMode.STOP_AT_MAX)
                							.withReset(beginCalc);
                Counter GammaCounter = control.count.makeCounter(GammaCounterParam);
                DFEVar GammaCount = GammaCounter.getCount();

		// Address is valid when it's smaller than Max                
                DFEVar Valid = beginCalc | (GammaCount>0) & (GammaCount<Max);
                hasFinish = Valid & (GammaCount === SSizeForGammaCalc);
		
		
		/////////////////////// Calculation ///////////////////////
		
		DFEVar toAccumulator = beginCalc ? (Q+beta) : (Q*beta);
		Result = FloatingPointAccumulator.accumulateWithReset(toAccumulator, Valid, beginCalc, true);
		
		
		/////////////////////// Memory ///////////////////////
		
		Memory<DFEVar> GammaMem = mem.alloc(Def.CalcType, WinSize);
		Data = GammaMem.read(GammaReadAddr);
		DFEVar WrEn = GammaWriteEn & hasFinish;
		GammaMem.write(GammaWriteAddr, Result, WrEn);

//		DFEVar Tick = control.count.simpleCounter(32);
//		debug.simPrintf(Valid, "[%4d] [GAMMACALC] beginCalc=%d, GammaCount=%d | Result = %f, WrEn=%d | hasFinish=%d \n", Tick, beginCalc, GammaCount, Result, WrEn, hasFinish);

	}

}
