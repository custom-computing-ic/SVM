import com.maxeler.maxcompiler.v2.kernelcompiler.KernelLib;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.memory.Memory;

import maxpower.FloatingPointAccumulator;

/**
 * This class calculates hXi
 *	- Floating point accumulator from MaxPower is used
 *	- blockDim should be at least ~15 to ensure correctness, depending on pipelining factor
 *
 *
 * @author Patrick Shao
 *
 * @param <blockDim> 1D Dimension of the block - Block Size = blockDim^2
 * @param <Q> Incoming Q vector from KernelCalc - width = numBlocks
 * @param <theta> Incoming theta vector - width = numBlocks
 * @param <b> Offset b
 * @param <Y> Yc
 * @param <beginCalc> valid on the cycle that the first item arrives
 * 
 */



class hCalc extends KernelLib {

	private DFEVar Result;
	private DFEVar fromMem;
	private DFEVar Valid;
		
	public DFEVar getCalcResult() 			{return Result;}
	public DFEVar getMemData() 			{return fromMem;}
	public DFEVar isValid() 				{return Valid;}
	
	hCalc ( 	KernelLib owner, 
			int numBlocks, 
			int blockDim, 
			DFEVector<DFEVar> Q, 
			DFEVector<DFEVar> theta, 
			DFEVar b, 
			DFEVar Y, 
			DFEVar beginCalc, 
			DFEVar RdAddr,
			DFEVar WrAddr,
			DFEVar ExtWrData,
			DFEVar WrEn) 
	{
	
		super(owner);
		
		/////////////////////// Control ///////////////////////
		
		AddrGenerator AddrGen = new AddrGenerator(owner, 1, blockDim, beginCalc);
                DFEVar Addr = AddrGen.getAddr();
                DFEVar EnAccumulation = AddrGen.isValid();
                Valid = (Addr === blockDim-1);
		
		/////////////////////// Calculation ///////////////////////
		
		DFEVector<DFEVar> mult = theta * Q;
		DFEVar offset = b - Y;
		DFEVar sum = FloatingPointAccumulator.accumulateFixedLength(mult.getElementsAsList(), EnAccumulation, blockDim, false);
		Result = sum+offset;
		
		/////////////////////// Memory ///////////////////////
		
		Memory<DFEVar> hXiMem = mem.alloc(Def.CalcType, numBlocks*blockDim);
		hXiMem.mapToCPU("hXi");
		DFEVar WrData 	= EnAccumulation ? Result : ExtWrData;
		DFEVar EnWrite 	= EnAccumulation ? Valid : WrEn;
		hXiMem.write(WrAddr, WrData, EnWrite);
		fromMem = hXiMem.read(RdAddr);
		
		// Debug
		debug.simPrintf(EnAccumulation, "[%4d] [hCalc] Addr=%2d, | Q[0:3]=(%.4f,%.4f,%.4f,%.4f) theta[0:3]=(%.4f,%.4f,%.4f,%.4f) | b = %f | hXi = %f, Valid=%d\n", control.count.simpleCounter(32), Addr, Q[0], Q[1], Q[2], Q[3], theta[0], theta[1], theta[2], theta[3], b, Result, Valid);
		
	}

}
